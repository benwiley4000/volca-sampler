{"version":3,"sources":["SampleList.js","store.js","utils/audioData.js","utils/constants.js","Waveform.js","utils/getSyroBindings.js","utils/syro.js","SampleDetail.js","utils/recording.js","SampleRecord.js","App.js","reportWebVitals.js","index.js"],"names":["style","document","createElement","innerHTML","body","appendChild","classes","reduce","className","SampleList","samples","selectedSampleId","readonly","onNewSample","onSampleSelect","sampleList","sampleListItem","onClick","map","id","sample","backgroundColor","undefined","metadata","name","Date","dateModified","toLocaleString","wavDataStore","localforage","createInstance","driver","INDEXEDDB","sampleMetadataStore","storeWavSourceFile","wavData","a","uuidv4","setItem","METADATA_VERSION","SampleContainer","sourceFileId","slotNumber","dateSampled","now","useCompression","qualityBitDepth","normalize","clip","this","metadataVersion","copy","Mutable","persist","data","sourceFileData","set","recentlyCachedSourceFileIds","filter","stale","slice","MAX_CACHED","delete","get","includes","fetch","arrayBuffer","buffer","Uint8Array","cacheSourceFileData","getItem","Promise","reject","sampleMetadata","Map","iterate","console","warn","keys","sourceIds","concat","factorySampleParams","sampleContainers","Boolean","sort","b","sampleContainerParams","setTimeout","update","newMetadata","newContainer","removeItem","targetAudioContext","factorySamples","params","SAMPLE_RATE","resampleToTargetSampleRate","sourceAudioBuffer","sampleRate","ratio","offlineContext","OfflineAudioContext","numberOfChannels","length","offlineSource","createBufferSource","connect","destination","start","startRendering","audioBufferResampled","getClippedView","array","clipFrames","byteOffset","viewLength","Float32Array","getMonoSamplesFromAudioBuffer","audioBuffer","clippedLength","channels","Array","fill","_","i","getChannelData","monoSample","j","findSamplePeak","peak","abs","Math","scaleSamples","coef","normalizeSamples","peakTarget","applyQualityBitDepthToSamples","signedMax","round","convertSamplesTo16Bit","samples16","Int16Array","getTargetAudioContext","AudioContext","getAudioBufferForAudioFileData","audioFileBuffer","bufferCopy","resolve","decodeAudioData","convertWavTo16BitMono","sampleContainer","Number","isInteger","Error","getSourceFileData","wavSrcAudioBuffer","c","samplesByteLength","wavHeader","getWavFileHeaders","bitDepth","dataLength","wavBuffer","Waveform","syroBindingsPromise","onSetNormalize","onSetClip","useState","monoSamples","setMonoSamples","useEffect","cancelled","fileData","ref","useRef","peaks","useMemo","pixelWidth","current","offsetWidth","positive","negative","groupSize","floor","group","max","min","getPeaksForSamples","samplePeak","scaleCoefficient","width","height","position","overflow","display","alignItems","willChange","call","amplitude","index","paddingRight","top","left","type","value","step","onChange","e","target","getSyroBindings","window","CREATE_SYRO_BINDINGS","Module","syroBindings","prepareSampleBufferFromWavData","cwrap","prepareSampleBufferFrom16BitPcmData","startSampleBufferFrom16BitPcmData","iterateSampleBuffer","getSampleBufferPointer","getSampleBufferSize","getSampleBufferProgress","freeSampleBuffer","heap8Buffer","HEAP8","err","getSampleBuffer","onProgress","pcmData","bufferPointer","bufferSize","resultView","lastTime","targetIterationTime","lastIterationInterval","requestAnimationFrame","correctionCoefficient","iterationInterval","before","performance","sampleBuffer","playAudioFile","blob","Blob","audioElement","src","URL","createObjectURL","play","onended","revokeObjectURL","SampleDetail","recordingAudioContext","recorderWorkletProcessorPromise","onSampleUpdate","onSampleDuplicate","onSampleDelete","sampleDetail","confirm","clipStart","clipEnd","maxWidth","disabled","url","href","download","click","remove","log","error","getRecordingAudioContext","navigator","mediaDevices","getSupportedConstraints","enumerateDevices","devices","audioInputDevices","device","kind","all","getUserMedia","audio","deviceId","channelCount","video","stream","channelsAvailable","getAudioTracks","getTracks","stop","createAudioWorkletPcmRecorderNode","onData","onFinish","audioContext","audioWorklet","addModule","recorderNode","AudioWorkletNode","parameterData","port","onmessage","eventType","audioChannels","isRecordingParam","parameters","setValueAtTime","currentTime","createScriptProcessorPcmRecorderNode","createScriptProcessor","stopped","onaudioprocess","inputBuffer","createPcmRecorderNode","options","captureAudio","finished","recordedChunks","chunks","merged","len","chunk","offset","wav","WaveFile","fromScratch","onDone","toBuffer","onError","tracks","disconnect","mediaStreamSourceNode","sampleCount","channel","chunkSize","chunkSliced","maxSamples","samplesRecorded","push","onStart","echoCancellation","autoGainControl","noiseSuppression","createMediaStreamSource","mediaRecording","useMediaRecording","onRecordStart","onRecordFinish","onRecordError","captureDevices","setCaptureDevices","selectedCaptureDeviceId","setSelectedCaptureDeviceId","getAudioInputDevices","then","d","selectedChannelCount","setSelectedChannelCount","selectedDeviceInfo","recordingError","setRecordingError","fn","setStop","handleBeginRecording","useCallback","beginRecording","stopRecording","SampleRecord","captureState","paddingLeft","label","count","has","App","showingFactorySamples","setShowingFactorySamples","setSamples","focusedSampleId","setFocusedSampleId","setLoadingSamples","setCaptureState","selectedSampleBank","getAllFromStorage","storedSamples","finally","size","values","handleRecordStart","handleRecordFinish","handleRecordError","volcaSampler","JSON","stringify","parse","sampleListContainer","focusedSampleContainer","newSample","duplicate","newSamples","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.72e7d30f.chunk.js","sourcesContent":["import React from 'react';\n\n{\n  const css = `\n.sampleList {\n  height: 100%;\n  overflow: auto;\n}\n\n.sampleListItem {\n  padding: 0.5rem;\n  border: 1px solid grey;\n  cursor: pointer;\n}\n\n.sampleListItem:not:nth-child(1) {\n  margin-top: 1rem;\n}\n  `;\n  const style = document.createElement('style');\n  style.innerHTML = css;\n  document.body.appendChild(style);\n}\n/**\n * @type {Record<string, string>}\n */\nconst classes = ['sampleList', 'sampleListItem'].reduce(\n  (classes, className) => ({ ...classes, [className]: className }),\n  {}\n);\n\n/**\n * @param {{\n *   samples: Map<string, import('./store').SampleContainer>;\n *   selectedSampleId: string | null;\n *   readonly: boolean;\n *   onNewSample: () => void;\n *   onSampleSelect: (id: string) => void;\n * }} props\n */\nfunction SampleList({ samples, selectedSampleId, readonly, onNewSample, onSampleSelect }) {\n  return (\n    <div className={classes.sampleList}>\n      <div\n        data-disabled={readonly}\n        className={classes.sampleListItem}\n        onClick={() => !readonly && onNewSample()}\n      >\n        New Sample\n      </div>\n      {[...samples].map(([id, sample]) => (\n        <div\n          key={id}\n          className={classes.sampleListItem}\n          style={{ backgroundColor: id === selectedSampleId ? '#f3f3f3' : undefined }}\n          data-disabled={readonly}\n          onClick={() => !readonly && onSampleSelect(id)}\n        >\n          <div>{sample.metadata.name}</div>\n          <div>\n            Updated {new Date(sample.metadata.dateModified).toLocaleString()}\n          </div>\n        </div>\n      ))}\n    </div>\n  );\n}\n\nexport default SampleList;\n","import localforage from 'localforage';\nimport { v4 as uuidv4 } from 'uuid';\n\nimport factorySampleParams from './factory-samples.json';\n\n/**\n * @typedef {object} SampleContainerParams\n * @property {string} name\n * @property {string} sourceFileId\n * @property {string} [id]\n * @property {number} [slotNumber]\n * @property {number} [dateSampled]\n * @property {number} [dateModified]\n * @property {boolean} [useCompression]\n * @property {number} [qualityBitDepth]\n * @property {number | false} [normalize]\n * @property {[number, number]} [clip]\n */\n\n/**\n * @typedef {object} SampleMetadata\n * @property {string} name\n * @property {string} sourceFileId\n * @property {number} slotNumber\n * @property {number} dateSampled\n * @property {number} dateModified\n * @property {boolean} useCompression\n * @property {number} qualityBitDepth\n * @property {number | false} normalize\n * @property {[number, number]} clip\n * @property {string} metadataVersion\n */\n\n/**\n * @typedef {object} SampleMetadataUpdate\n * @property {string} [name]\n * @property {number} [slotNumber]\n * @property {boolean} [useCompression]\n * @property {number} [qualityBitDepth]\n * @property {number | false} [normalize]\n * @property {[number, number]} [clip]\n */\n\nconst wavDataStore = localforage.createInstance({\n  name: 'wav_data',\n  driver: localforage.INDEXEDDB,\n});\n\nconst sampleMetadataStore = localforage.createInstance({\n  name: 'sample_metadata',\n  driver: localforage.INDEXEDDB,\n});\n\n/**\n * @param {Uint8Array} wavData\n * @returns {Promise<string>} id\n */\nexport async function storeWavSourceFile(wavData) {\n  const id = uuidv4();\n  await wavDataStore.setItem(id, wavData);\n  return id;\n}\n\nconst METADATA_VERSION = '0.1.0';\n\nexport class SampleContainer {\n  /**\n   * @param {SampleContainerParams} sampleContainerParams\n   */\n  constructor({\n    name,\n    sourceFileId,\n    id = uuidv4(),\n    slotNumber = 0,\n    dateSampled = Date.now(),\n    dateModified = dateSampled,\n    useCompression = false,\n    qualityBitDepth = 16,\n    normalize = false,\n    clip = [0, 0],\n  }) {\n    /** @readonly */\n    this.id = id;\n    /**\n     * @readonly\n     * @type {SampleMetadata}\n     */\n    this.metadata = {\n      name,\n      sourceFileId,\n      slotNumber,\n      dateSampled,\n      dateModified,\n      useCompression,\n      qualityBitDepth,\n      normalize,\n      clip,\n      metadataVersion: METADATA_VERSION,\n    };\n  }\n\n  /**\n   * @returns {SampleContainer}\n   */\n  duplicate() {\n    const copy = new SampleContainer.Mutable({\n      ...this.metadata,\n      name: `${this.metadata.name} (copy)`,\n      dateModified: Date.now(),\n    });\n    // async - does not block\n    copy.persist();\n    return copy;\n  }\n\n  static Mutable = class extends SampleContainer {\n    /**\n     * @param {SampleContainerParams} sampleContainerParams\n     */\n    constructor(sampleContainerParams) {\n      super(sampleContainerParams);\n      setTimeout(async () => {\n        const ids = await sampleMetadataStore.keys();\n        if (!ids.includes(this.id)) {\n          console.warn(\n            `Expected sample metadata container ${this.id} to be persisted`\n          );\n        }\n      });\n    }\n\n    async persist() {\n      await sampleMetadataStore.setItem(this.id, this.metadata);\n    }\n\n    /**\n     * @param {SampleMetadataUpdate} update\n     * @returns {SampleContainer}\n     */\n    update(update) {\n      const { id, metadata } = this;\n      /**\n       * @type {SampleMetadata}\n       */\n      const newMetadata = {\n        ...metadata,\n        ...update,\n        dateModified: Date.now(),\n      };\n      const newContainer = new SampleContainer.Mutable({ id, ...newMetadata });\n      // async - does not block\n      newContainer.persist();\n      return newContainer;\n    }\n\n    async remove() {\n      await sampleMetadataStore.removeItem(this.id);\n    }\n  };\n\n  /**\n   * @private\n   * @type {Map<string, Uint8Array>}\n   */\n  static sourceFileData = new Map();\n\n  /**\n   * @private\n   * @type {string[]}\n   */\n  static recentlyCachedSourceFileIds = [];\n\n  /** @readonly @private */\n  static MAX_CACHED = 10;\n\n  /**\n   * @param {string} sourceFileId\n   * @param {Uint8Array} data\n   */\n  static cacheSourceFileData(sourceFileId, data) {\n    this.sourceFileData.set(sourceFileId, data);\n    this.recentlyCachedSourceFileIds = [\n      sourceFileId,\n      ...this.recentlyCachedSourceFileIds.filter((id) => id !== sourceFileId),\n    ];\n    const stale = this.recentlyCachedSourceFileIds.slice(this.MAX_CACHED);\n    for (const sourceFileId of stale) {\n      this.sourceFileData.delete(sourceFileId);\n    }\n    this.recentlyCachedSourceFileIds = this.recentlyCachedSourceFileIds.slice(\n      0,\n      this.MAX_CACHED\n    );\n  }\n\n  /**\n   * @param {string} sourceFileId\n   * @returns {Promise<Uint8Array>}\n   */\n  static async getSourceFileData(sourceFileId) {\n    {\n      const data = this.sourceFileData.get(sourceFileId);\n      if (data) {\n        return data;\n      }\n    }\n    if (sourceFileId.includes('.')) {\n      // assume it's a URL pointing to a WAV file\n      const buffer = await (await fetch(sourceFileId)).arrayBuffer();\n      const data = new Uint8Array(buffer);\n      this.cacheSourceFileData(sourceFileId, data);\n      return data;\n    }\n    /**\n     * @type {unknown}\n     */\n    const data = await wavDataStore.getItem(sourceFileId);\n    if (data) {\n      if (data instanceof Uint8Array) {\n        this.cacheSourceFileData(sourceFileId, data);\n        return data;\n      }\n      return Promise.reject('Source data is of unexpected type');\n    }\n    return Promise.reject('Missing source data');\n  }\n\n  static async getAllFromStorage() {\n    /**\n     * @type {Map<string, SampleMetadata>}\n     */\n    const sampleMetadata = new Map();\n    await sampleMetadataStore.iterate((metadata, id) => {\n      if (metadata && metadata.metadataVersion === METADATA_VERSION) {\n        sampleMetadata.set(id, metadata);\n      } else {\n        // TODO: handle upgrade\n        console.warn(\n          `Found metadata \"${metadata.name || id} with unhandled version ${\n            metadata.metadataVersion\n          }\"; ignoring.`\n        );\n      }\n    });\n    const sourceIds = (await wavDataStore.keys()).concat(\n      factorySampleParams.map(({ sourceFileId }) => sourceFileId)\n    );\n    const sampleContainers = /** @type {SampleContainer[]} */ (\n      [...sampleMetadata]\n        .map(([id, metadata]) => {\n          const { sourceFileId } = metadata;\n          if (!sourceIds.includes(sourceFileId)) {\n            console.warn(\n              `Found metadata \"${\n                metadata.name || id\n              }\" with missing data \"${sourceFileId}; ignoring.`\n            );\n            return null;\n          }\n          return new SampleContainer.Mutable({ id, ...metadata });\n        })\n        .filter(Boolean)\n    ).sort((a, b) => b.metadata.dateModified - a.metadata.dateModified);\n    return sampleContainers;\n  }\n}\n\nexport const factorySamples = new Map(\n  factorySampleParams.map((params) => [params.id, new SampleContainer(params)])\n);\n","import getWavFileHeaders from 'wav-headers';\n\nimport { SampleContainer } from '../store';\nimport { SAMPLE_RATE } from './constants';\n\n/**\n * @param {AudioBuffer} sourceAudioBuffer\n * @returns {Promise<AudioBuffer>}\n */\nasync function resampleToTargetSampleRate(sourceAudioBuffer) {\n  if (sourceAudioBuffer.sampleRate === SAMPLE_RATE) {\n    return sourceAudioBuffer;\n  }\n  const ratio = SAMPLE_RATE / sourceAudioBuffer.sampleRate;\n  const offlineContext = new OfflineAudioContext(\n    sourceAudioBuffer.numberOfChannels,\n    sourceAudioBuffer.length * ratio,\n    SAMPLE_RATE\n  );\n  const offlineSource = offlineContext.createBufferSource();\n  offlineSource.buffer = sourceAudioBuffer;\n  offlineSource.connect(offlineContext.destination);\n  offlineSource.start();\n  const audioBufferResampled = await offlineContext.startRendering();\n  return audioBufferResampled;\n}\n\n/**\n * @param {Float32Array} array\n * @param {[number, number]} clipFrames\n */\nfunction getClippedView(array, clipFrames) {\n  const frameSizeInBytes = 4;\n  const byteOffset = clipFrames[0] * frameSizeInBytes;\n  const viewLength = array.length - clipFrames[0] - clipFrames[1];\n  return new Float32Array(array.buffer, byteOffset, viewLength);\n}\n\n/**\n * @param {AudioBuffer} audioBuffer\n * @param {[number, number]} clipFrames\n */\nexport function getMonoSamplesFromAudioBuffer(audioBuffer, clipFrames) {\n  const clippedLength = audioBuffer.length - clipFrames[0] - clipFrames[1];\n  const samples = new Float32Array(clippedLength);\n  const channels = /** @type {void[]} */ (Array(audioBuffer.numberOfChannels))\n    .fill()\n    .map((_, i) => getClippedView(audioBuffer.getChannelData(i), clipFrames));\n  for (let i = 0; i < clippedLength; i++) {\n    let monoSample = 0;\n    for (let j = 0; j < channels.length; j++) {\n      monoSample += channels[j][i];\n    }\n    monoSample /= channels.length;\n    samples[i] = monoSample;\n  }\n  return samples;\n}\n\n/**\n * Finds most significant magnitude in array of samples.\n * @param {Float32Array} samples array of floats between -1 and 1\n * @returns {number} peak value between 0 and 1\n */\nexport function findSamplePeak(samples) {\n  let peak = 0;\n  for (const sample of samples) {\n    const abs = Math.abs(sample);\n    if (abs > peak) {\n      peak = abs;\n    }\n  }\n  return peak;\n}\n\n/**\n * Scales an array of samples according to a specified coefficient.\n * Note: mutates input array (no return value).\n * @param {Float32Array} samples array of floats\n * @param {number} coef float value to multiply against each sample\n */\nfunction scaleSamples(samples, coef) {\n  if (coef !== 1) {\n    for (let i = 0; i < samples.length; i++) {\n      samples[i] *= coef;\n    }\n  }\n}\n\n/**\n * Normalizes samples by adjusting max value to 1 and scaling others by same\n * coefficient. Note: mutates input array (no return value).\n * @param {Float32Array} samples array of floats between -1 and 1\n * @param {number} peakTarget float between 0 and 1\n */\nfunction normalizeSamples(samples, peakTarget = 1) {\n  const coef = peakTarget / findSamplePeak(samples);\n  scaleSamples(samples, coef);\n}\n\n/**\n * Reduces precision of samples by converting them to integers of a given bit\n * depth then back to floats. Note: mutates input array (no return value).\n * @param {Float32Array} samples array of floats between -1 and 1\n * @param {number} qualityBitDepth number from 8 to 16\n */\nfunction applyQualityBitDepthToSamples(samples, qualityBitDepth) {\n  const signedMax = 2 ** (qualityBitDepth - 1);\n  for (let i = 0; i < samples.length; i++) {\n    samples[i] = Math.round(samples[i] * signedMax) / signedMax;\n  }\n}\n\n/**\n * @param {Float32Array} samples\n */\nfunction convertSamplesTo16Bit(samples) {\n  const samples16 = new Int16Array(samples.length);\n  const signedMax = 2 ** 15;\n  for (let i = 0; i < samples.length; i++) {\n    samples16[i] = samples[i] === 1 ? signedMax - 1 : signedMax * samples[i];\n  }\n  return samples16;\n}\n\n/**\n * @type {AudioContext | undefined}\n */\nlet targetAudioContext;\n\nfunction getTargetAudioContext() {\n  return (targetAudioContext =\n    targetAudioContext || new AudioContext({ sampleRate: SAMPLE_RATE }));\n}\n\n/**\n * @param {Uint8Array} audioFileBuffer audio file to transform into audio buffer\n * @returns {Promise<AudioBuffer>}\n */\nexport async function getAudioBufferForAudioFileData(audioFileBuffer) {\n  // make a copy of the data (since decodeAudioData will empty the source array)\n  const bufferCopy = new Uint8Array(audioFileBuffer);\n  /**\n   * @type {AudioBuffer}\n   */\n  const audioBuffer = await new Promise((resolve, reject) => {\n    getTargetAudioContext().decodeAudioData(bufferCopy.buffer, resolve, reject);\n  });\n  return audioBuffer;\n}\n\n/**\n * @param {import('../store').SampleContainer} sampleContainer\n * @returns {Promise<{ data: Uint8Array; sampleRate: number }>}\n */\nexport async function convertWavTo16BitMono(sampleContainer) {\n  const { qualityBitDepth, normalize, clip } = sampleContainer.metadata;\n  if (\n    qualityBitDepth < 8 ||\n    qualityBitDepth > 16 ||\n    !Number.isInteger(qualityBitDepth)\n  ) {\n    throw new Error(\n      `Expected bit depth between 8 and 16. Received: ${qualityBitDepth}`\n    );\n  }\n  const wavSrcAudioBuffer = await resampleToTargetSampleRate(\n    await getAudioBufferForAudioFileData(\n      await SampleContainer.getSourceFileData(\n        sampleContainer.metadata.sourceFileId\n      )\n    )\n  );\n  const clipFrames = /** @type {[number, number]} */ (\n    clip.map((c) => Math.round(c * wavSrcAudioBuffer.sampleRate))\n  );\n  const samples =\n    wavSrcAudioBuffer.numberOfChannels === 1\n      ? getClippedView(wavSrcAudioBuffer.getChannelData(0), clipFrames)\n      : getMonoSamplesFromAudioBuffer(wavSrcAudioBuffer, clipFrames);\n  if (normalize) {\n    normalizeSamples(samples, normalize);\n  }\n  if (qualityBitDepth < 16) {\n    applyQualityBitDepthToSamples(samples, qualityBitDepth);\n  }\n  const samples16 = convertSamplesTo16Bit(samples);\n  const samplesByteLength = samples16.length * 2;\n  /**\n   * @type {Uint8Array}\n   */\n  const wavHeader = getWavFileHeaders({\n    channels: 1,\n    sampleRate: wavSrcAudioBuffer.sampleRate,\n    bitDepth: 16,\n    dataLength: samplesByteLength,\n  });\n  const wavBuffer = new Uint8Array(wavHeader.length + samplesByteLength);\n  wavBuffer.set(wavHeader);\n  wavBuffer.set(new Uint8Array(samples16.buffer), wavHeader.length);\n  return {\n    data: wavBuffer,\n    sampleRate: 16,\n  };\n}\n","export const SAMPLE_RATE = 31250;\n","import React, { useEffect, useMemo, useRef, useState } from 'react';\n\nimport {\n  getAudioBufferForAudioFileData,\n  getMonoSamplesFromAudioBuffer,\n  findSamplePeak,\n} from './utils/audioData';\nimport { SampleContainer } from './store';\n\n/**\n * @param {Float32Array} samples an array of floats from -1 to 1\n * @param {number} groupSize the number of samples represented for each peak\n * @returns {{\n *   positive: Float32Array;\n *   negative: Float32Array;\n * }} arrays of peak positive and negative values\n */\nfunction getPeaksForSamples(samples, groupSize) {\n  // Cut off whatever's left after dividing into blocks of length [groupSize]\n  const positive = new Float32Array(Math.floor(samples.length / groupSize));\n  const negative = new Float32Array(Math.floor(samples.length / groupSize));\n  for (let i = 0; i < positive.length; i++) {\n    const group = new Float32Array(\n      samples.buffer,\n      i * groupSize * 4,\n      groupSize\n    );\n    let max = 0;\n    let min = 0;\n    for (const sample of group) {\n      if (sample > max) {\n        max = sample;\n      }\n      if (sample < min) {\n        min = sample;\n      }\n    }\n    positive[i] = max;\n    negative[i] = min;\n  }\n  return { positive, negative };\n}\n\n/**\n * @param {{\n *   sample: import('./store').SampleContainer;\n *   onSetClip: (clip: [number, number]) => void;\n *   onSetNormalize: (normalize: number | false) => void;\n * }} props\n */\nfunction Waveform({ sample, onSetClip, onSetNormalize }) {\n  const [monoSamples, setMonoSamples] = useState(new Float32Array());\n  useEffect(() => {\n    let cancelled = false;\n    (async () => {\n      if (cancelled) return;\n      const fileData = await SampleContainer.getSourceFileData(\n        sample.metadata.sourceFileId\n      );\n      if (cancelled) return;\n      const audioBuffer = await getAudioBufferForAudioFileData(fileData);\n      if (cancelled) return;\n      const monoSamples = getMonoSamplesFromAudioBuffer(audioBuffer, [0, 0]);\n      setMonoSamples(monoSamples);\n    })();\n    return () => {\n      cancelled = true;\n    };\n  }, [sample.metadata.sourceFileId]);\n\n  /**\n   * @type {React.RefObject<HTMLDivElement>}\n   */\n  const ref = useRef(null);\n  const groupWidth = 6;\n  const peaks = useMemo(() => {\n    const pixelWidth = ref.current && ref.current.offsetWidth;\n    if (!pixelWidth || !monoSamples.length) {\n      return {\n        positive: new Float32Array(),\n        negative: new Float32Array(),\n      };\n    }\n    const groupSize = Math.floor(\n      (groupWidth * monoSamples.length) / pixelWidth\n    );\n    return getPeaksForSamples(monoSamples, groupSize);\n  }, [monoSamples]);\n  const samplePeak = useMemo(\n    () =>\n      Math.max(findSamplePeak(peaks.negative), findSamplePeak(peaks.positive)),\n    [peaks]\n  );\n  const peakTarget = sample.metadata.normalize || samplePeak;\n  const scaleCoefficient = peakTarget / samplePeak;\n\n  return (\n    <div\n      className=\"waveform\"\n      style={{\n        width: '100%',\n        height: '100%',\n        position: 'relative',\n        overflow: 'hidden',\n      }}\n      ref={ref}\n    >\n      <div\n        className=\"positive\"\n        style={{\n          width: '100%',\n          height: '67%',\n          display: 'flex',\n          alignItems: 'flex-end',\n        }}\n      >\n        <div\n          className=\"scaled\"\n          style={{\n            width: '100%',\n            height: `${100 * scaleCoefficient}%`,\n            willChange: 'height',\n            display: 'flex',\n            alignItems: 'flex-end',\n          }}\n        >\n          {[].map.call(peaks.positive, (amplitude, index) => (\n            <div\n              key={index}\n              className=\"bar\"\n              style={{\n                width: groupWidth,\n                height: `${100 * amplitude}%`,\n                paddingRight: 1,\n              }}\n            >\n              <div\n                className=\"bar_inner\"\n                style={{ backgroundColor: 'red', height: '100%' }}\n              />\n            </div>\n          ))}\n        </div>\n      </div>\n      <div\n        className=\"negative\"\n        style={{\n          width: '100%',\n          height: '33%',\n          display: 'flex',\n          alignItems: 'flex-start',\n        }}\n      >\n        <div\n          className=\"scaled\"\n          style={{\n            width: '100%',\n            height: `${100 * scaleCoefficient}%`,\n            willChange: 'height',\n            display: 'flex',\n            alignItems: 'flex-start',\n          }}\n        >\n          {[].map.call(peaks.negative, (amplitude, index) => (\n            <div\n              key={index}\n              className=\"bar\"\n              style={{\n                width: groupWidth,\n                height: `${100 * -amplitude}%`,\n                paddingRight: 1,\n              }}\n            >\n              <div\n                className=\"bar_inner\"\n                style={{ backgroundColor: 'darkred', height: '100%' }}\n              />\n            </div>\n          ))}\n        </div>\n      </div>\n      <input\n        style={{ position: 'absolute', top: 0, left: 0 }}\n        type=\"range\"\n        value={sample.metadata.normalize || undefined}\n        min={0.1}\n        max={1}\n        step={0.01}\n        onChange={(e) => onSetNormalize(Number(e.target.value))}\n      />\n    </div>\n  );\n}\n\nexport default Waveform;\n","// @ts-nocheck\n\n/**\n * @typedef {{\n *   prepareSampleBufferFromWavData: (\n *     wavData: Uint8Array,\n *     bytes: number,\n *     slotNumber: number,\n *     quality: number,\n *     useCompression: 0 | 1\n *   ) => number;\n *   prepareSampleBufferFrom16BitPcmData(\n *     wavData: Uint8Array,\n *     bytes: number,\n *     rate: number,\n *     slotNumber: number,\n *     quality: number,\n *     useCompression: 0 | 1\n *   ) => number;\n *   startSampleBufferFrom16BitPcmData(\n *     wavData: Uint8Array,\n *     bytes: number,\n *     rate: number,\n *     slotNumber: number,\n *     quality: number,\n *     useCompression: 0 | 1\n *   ) => number;\n *   iterateSampleBuffer: (iterations: number) => void;\n *   getSampleBufferPointer: () => number;\n *   getSampleBufferSize: () => number;\n *   getSampleBufferProgress: () => number;\n *   freeSampleBuffer: () => void;\n *   heap8Buffer: () => ArrayBuffer;\n * }} SyroBindings\n */\n\n/**\n * @type {Promise<SyroBindings> | undefined}\n */\nlet syroBindingsPromise;\n\nexport async function getSyroBindings() {\n  if (typeof window.CREATE_SYRO_BINDINGS !== 'function') {\n    return Promise.reject(\n      'Expected CREATE_SYRO_BINDINGS global function to exist'\n    );\n  }\n  const Module = await window.CREATE_SYRO_BINDINGS();\n  return (syroBindingsPromise =\n    syroBindingsPromise ||\n    new Promise((resolve, reject) => {\n      /**\n       * @type {SyroBindings}\n       */\n      let syroBindings;\n      try {\n        syroBindings = {\n          prepareSampleBufferFromWavData: Module.cwrap(\n            'prepareSampleBufferFromWavData',\n            'number',\n            ['array', 'number', 'number', 'number']\n          ),\n          prepareSampleBufferFrom16BitPcmData: Module.cwrap(\n            'prepareSampleBufferFrom16BitPcmData',\n            'number',\n            ['array', 'number', 'number', 'number', 'number']\n          ),\n          startSampleBufferFrom16BitPcmData: Module.cwrap(\n            'startSampleBufferFrom16BitPcmData',\n            'number',\n            ['array', 'number', 'number', 'number', 'number']\n          ),\n          iterateSampleBuffer: Module.cwrap('iterateSampleBuffer', null, [\n            'number',\n          ]),\n          getSampleBufferPointer: Module.cwrap(\n            'getSampleBufferPointer',\n            'number',\n            []\n          ),\n          getSampleBufferSize: Module.cwrap(\n            'getSampleBufferSize',\n            'number',\n            []\n          ),\n          getSampleBufferProgress: Module.cwrap(\n            'getSampleBufferProgress',\n            'number',\n            []\n          ),\n          freeSampleBuffer: Module.cwrap('freeSampleBuffer', null, []),\n          heap8Buffer() {\n            return Module.HEAP8.buffer;\n          },\n        };\n      } catch (err) {\n        reject(err);\n        return;\n      }\n      resolve(syroBindings);\n    }));\n}\n","import { getSyroBindings } from './getSyroBindings';\nimport { convertWavTo16BitMono } from './audioData';\n\n/**\n * @param {import('../store').SampleContainer} sampleContainer\n * @param {(progress: number) => void} onProgress\n * @returns {Promise<Uint8Array>}\n */\nexport async function getSampleBuffer(sampleContainer, onProgress) {\n  const {\n    startSampleBufferFrom16BitPcmData,\n    iterateSampleBuffer,\n    getSampleBufferPointer,\n    getSampleBufferSize,\n    getSampleBufferProgress,\n    freeSampleBuffer,\n    heap8Buffer,\n  } = await getSyroBindings();\n  const { data, sampleRate } = await convertWavTo16BitMono(sampleContainer);\n  const pcmData = data.slice(44);\n  const err = startSampleBufferFrom16BitPcmData(\n    pcmData,\n    pcmData.length,\n    sampleRate,\n    sampleContainer.metadata.slotNumber,\n    sampleContainer.metadata.qualityBitDepth,\n    sampleContainer.metadata.useCompression ? 1 : 0\n  );\n  if (err) {\n    return Promise.reject('Failed to prepare sample buffer');\n  }\n  const bufferPointer = getSampleBufferPointer();\n  const bufferSize = getSampleBufferSize();\n  const resultView = new Uint8Array(heap8Buffer(), bufferPointer, bufferSize);\n  onProgress(getSampleBufferProgress() / bufferSize);\n  await /** @type {Promise<void>} */ (\n    new Promise((resolve, reject) => {\n      const targetIterationTime = 10;\n      // assume we're behind at the start, to avoid starting with a long frame\n      let lastTime = targetIterationTime * 2;\n      let lastIterationInterval = 100_000;\n      requestAnimationFrame(iterate);\n      function iterate() {\n        if (getSampleBufferProgress() >= bufferSize) {\n          resolve();\n          return;\n        }\n        const correctionCoefficient = targetIterationTime / lastTime;\n        const iterationInterval = Math.max(\n          Math.round(lastIterationInterval * correctionCoefficient),\n          1\n        );\n        const before = performance.now();\n        try {\n          iterateSampleBuffer(iterationInterval);\n        } catch (err) {\n          reject(err);\n          return;\n        }\n        lastTime = performance.now() - before;\n        if (lastTime === 0) {\n          // to avoid divide-by-zero due to potential rounding in Firefox\n          // https://developer.mozilla.org/en-US/docs/Web/API/Performance/now#reduced_time_precision\n          lastTime = 0.5;\n        }\n        lastIterationInterval = iterationInterval;\n        onProgress(getSampleBufferProgress() / bufferSize);\n        requestAnimationFrame(iterate);\n      }\n    })\n  );\n  // save a new copy of the data before freeing the result\n  const sampleBuffer = new Uint8Array(resultView);\n  freeSampleBuffer();\n  return sampleBuffer;\n}\n","import React from 'react';\n\nimport Waveform from './Waveform';\nimport { SampleContainer } from './store';\nimport { convertWavTo16BitMono } from './utils/audioData';\nimport { getSampleBuffer } from './utils/syro';\n\n{\n  const css = `\n.sampleDetail {\n  padding-left: 2rem;\n}\n  `;\n  const style = document.createElement('style');\n  style.innerHTML = css;\n  document.body.appendChild(style);\n}\n/**\n * @type {Record<string, string>}\n */\nconst classes = ['sampleDetail'].reduce(\n  (classes, className) => ({ ...classes, [className]: className }),\n  {}\n);\n\n/**\n * @param {Uint8Array} audioFileBuffer audio file to transform into audio buffer\n */\n export function playAudioFile(audioFileBuffer) {\n  const blob = new Blob([audioFileBuffer], {\n    type: 'audio/x-wav',\n  });\n  const audioElement = document.createElement('audio');\n  audioElement.src = URL.createObjectURL(blob);\n  audioElement.play();\n  audioElement.onended = () => {\n    URL.revokeObjectURL(audioElement.src);\n  };\n}\n\n/**\n * @param {{\n *   sample: SampleContainer | null;\n *   onSampleUpdate: (id: string, update: import('./store').SampleMetadataUpdate) => void;\n *   onSampleDuplicate: (id: string) => void;\n *   onSampleDelete: (id: string) => void;\n * }} props\n */\nfunction SampleDetail({\n  sample,\n  onSampleUpdate,\n  onSampleDuplicate,\n  onSampleDelete,\n}) {\n  if (!sample) {\n    return null;\n  }\n  return (\n    <div className={classes.sampleDetail}>\n      <h3>{sample.metadata.name}</h3>\n      <button type=\"button\" onClick={() => onSampleDuplicate(sample.id)}>\n        Duplicate\n      </button>\n      <button\n        type=\"button\"\n        onClick={() => {\n          if (\n            window.confirm(\n              `Are you sure you want to delete ${sample.metadata.name}?`\n            )\n          ) {\n            onSampleDelete(sample.id);\n          }\n        }}\n      >\n        Remove\n      </button>\n      <h4>\n        Last edited: {new Date(sample.metadata.dateModified).toLocaleString()}\n      </h4>\n      <h4>Sampled: {new Date(sample.metadata.dateSampled).toLocaleString()}</h4>\n      <label>\n        <h4>Clip start</h4>\n        <input\n          type=\"number\"\n          value={sample.metadata.clip[0]}\n          step={0.1}\n          min={0}\n          onChange={(e) => {\n            const clipStart = Number(e.target.value);\n            onSampleUpdate(sample.id, {\n              clip: [clipStart, sample.metadata.clip[1]],\n            });\n          }}\n        />\n      </label>\n      <label>\n        <h4>Clip end</h4>\n        <input\n          type=\"number\"\n          value={sample.metadata.clip[1]}\n          step={0.1}\n          min={0}\n          onChange={(e) => {\n            const clipEnd = Number(e.target.value);\n            onSampleUpdate(sample.id, {\n              clip: [sample.metadata.clip[0], clipEnd],\n            });\n          }}\n        />\n      </label>\n      <div\n        style={{\n          height: 200,\n          backgroundColor: '#f3f3f3',\n          maxWidth: 400,\n        }}\n      >\n        <Waveform\n          onSetClip={() => null}\n          onSetNormalize={(normalize) =>\n            onSampleUpdate(sample.id, { normalize })\n          }\n          sample={sample}\n        />\n        <button\n          type=\"button\"\n          disabled={sample.metadata.normalize === 1}\n          onClick={() => onSampleUpdate(sample.id, { normalize: 1 })}\n        >\n          Normalize\n        </button>\n        <button\n          type=\"button\"\n          disabled={!sample.metadata.normalize}\n          onClick={() => onSampleUpdate(sample.id, { normalize: false })}\n        >\n          Original level\n        </button>\n        <button\n          type=\"button\"\n          onClick={async () => {\n            const { data } = await convertWavTo16BitMono(sample);\n            playAudioFile(data);\n          }}\n        >\n          regular play\n        </button>\n        <button\n          type=\"button\"\n          onClick={async () => {\n            const { data } = await convertWavTo16BitMono(sample);\n            const blob = new Blob([data], {\n              type: 'audio/x-wav',\n            });\n            const url = URL.createObjectURL(blob);\n            const a = document.createElement('a');\n            a.href = url;\n            a.download = `${sample.metadata.name}.wav`;\n            a.style.display = 'none';\n            document.body.appendChild(a);\n            a.click();\n            a.remove();\n            URL.revokeObjectURL(url);\n          }}\n        >\n          download\n        </button>\n      </div>\n      <h4>Quality bit depth: {sample.metadata.qualityBitDepth}</h4>\n      <input\n        type=\"range\"\n        value={sample.metadata.qualityBitDepth}\n        step={1}\n        min={8}\n        max={16}\n        onChange={(e) => {\n          const qualityBitDepth = Number(e.target.value);\n          onSampleUpdate(sample.id, { qualityBitDepth });\n        }}\n      />\n      <label>\n        <h4>Slot number</h4>\n        <input\n          type=\"number\"\n          value={sample.metadata.slotNumber}\n          step={1}\n          min={0}\n          max={99}\n          onChange={(e) => {\n            const slotNumber = Number(e.target.value);\n            onSampleUpdate(sample.id, { slotNumber });\n          }}\n        />\n      </label>\n      <button\n        type=\"button\"\n        onClick={async () => {\n          try {\n            const sampleBuffer = await getSampleBuffer(sample, console.log);\n            playAudioFile(sampleBuffer);\n          } catch (err) {\n            console.error(err);\n          }\n        }}\n      >\n        transfer to volca sample\n      </button>\n    </div>\n  );\n}\n\nexport default SampleDetail;\n","import { WaveFile } from 'wavefile';\n\nimport { SAMPLE_RATE } from './constants';\n\n/**\n * @type {AudioContext | undefined}\n */\nlet recordingAudioContext;\n\nfunction getRecordingAudioContext() {\n  return (recordingAudioContext =\n    recordingAudioContext ||\n    new AudioContext(\n      navigator.mediaDevices.getSupportedConstraints().sampleRate\n        ? { sampleRate: SAMPLE_RATE }\n        : {}\n    ));\n}\n\n/**\n * @typedef {{ device: MediaDeviceInfo; channelsAvailable: number }} AudioDeviceInfoContainer\n */\n\n/**\n * @returns {Promise<AudioDeviceInfoContainer[]>}\n */\nexport async function getAudioInputDevices() {\n  const devices = await navigator.mediaDevices.enumerateDevices();\n  const audioInputDevices = devices.filter(\n    (device) => device.kind === 'audioinput'\n  );\n  return Promise.all(\n    audioInputDevices.map(async (device) => {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        // try to grab stereo audio\n        audio: { deviceId: device.deviceId, channelCount: 2 },\n        video: false,\n      });\n      // TODO: validate this is the right way to get the channel count..\n      // maybe we have to wait for data available or something else?\n      const channelsAvailable = stream.getAudioTracks().length;\n      for (const track of stream.getTracks()) {\n        track.stop();\n      }\n      return {\n        device,\n        channelsAvailable,\n      };\n    })\n  );\n}\n\n/**\n * @typedef {Omit<AudioWorkletNode, 'parameters'> & {\n *   parameters: Map<'isRecording' | 'bufferSize', AudioParam>\n * }} TAudioWorkletNode\n */\n\n/**\n * @typedef {{\n *  channelCount: number;\n *  onData: (audioChannels: Float32Array[]) => void;\n *  onFinish: () => void;\n * }} PcmRecorderNodeOptions\n */\n\n/**\n * @type {Promise<void> | undefined}\n */\nlet recorderWorkletProcessorPromise;\n/**\n * @param {PcmRecorderNodeOptions} options\n * @returns {Promise<{ recorderNode: TAudioWorkletNode; stop: () => void }>}\n */\nasync function createAudioWorkletPcmRecorderNode({ onData, onFinish }) {\n  const audioContext = getRecordingAudioContext();\n  recorderWorkletProcessorPromise =\n    recorderWorkletProcessorPromise ||\n    audioContext.audioWorklet.addModule('/recorderWorkletProcessor.js');\n  await recorderWorkletProcessorPromise;\n  const recorderNode = /** @type {TAudioWorkletNode} */ (\n    new AudioWorkletNode(audioContext, 'recorder-worklet', {\n      parameterData: {\n        bufferSize: 1024,\n      },\n    })\n  );\n  recorderNode.port.onmessage = (e) => {\n    if (e.data.eventType === 'data') {\n      /**\n       * @type {Float32Array[]}\n       */\n      const audioChannels = e.data.audioChannels;\n      onData(audioChannels);\n    }\n\n    if (e.data.eventType === 'stop') {\n      onFinish();\n    }\n  };\n  const isRecordingParam = /** @type {AudioParam} */ (\n    recorderNode.parameters.get('isRecording')\n  );\n  isRecordingParam.setValueAtTime(1, audioContext.currentTime);\n  return {\n    recorderNode,\n    stop() {\n      isRecordingParam.setValueAtTime(0, audioContext.currentTime);\n    },\n  };\n}\n\n/**\n * @param {PcmRecorderNodeOptions} options\n * @returns {{ recorderNode: ScriptProcessorNode; stop: () => void }}\n */\nfunction createScriptProcessorPcmRecorderNode({\n  channelCount,\n  onData,\n  onFinish,\n}) {\n  const audioContext = getRecordingAudioContext();\n  const recorderNode = audioContext.createScriptProcessor(\n    1024,\n    channelCount,\n    channelCount\n  );\n  // to be set by user if they want to stop recording before time limit reached\n  let stopped = false;\n  recorderNode.onaudioprocess = (e) => {\n    const audioChannels = /** @type {void[]} */ (Array(channelCount))\n      .fill()\n      .map((_, i) => e.inputBuffer.getChannelData(i));\n    onData(audioChannels);\n    if (stopped) {\n      onFinish();\n    }\n  };\n  return {\n    recorderNode,\n    stop() {\n      stopped = true;\n    },\n  };\n}\n\n/**\n * @param {PcmRecorderNodeOptions} options\n * @returns {Promise<{ recorderNode: AudioNode; stop: () => void }>}\n */\nasync function createPcmRecorderNode(options) {\n  if (typeof AudioWorkletNode === 'undefined') {\n    return createScriptProcessorPcmRecorderNode(options);\n  }\n  return await createAudioWorkletPcmRecorderNode(options);\n}\n\n/**\n * @param {{\n *   deviceId: string;\n *   channelCount: number;\n *   onStart: () => void;\n * }} options\n * @returns {Promise<{ mediaRecording: Promise<Uint8Array>; stop: () => void }>}\n */\nexport async function captureAudio({ deviceId, channelCount, onStart }) {\n  const stream = await navigator.mediaDevices.getUserMedia({\n    // TODO: support more recording configuration options\n    // https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints#properties_of_audio_tracks\n    // autoGainControl, echoCancellation, latency, noiseSuppression, volume\n    audio: {\n      deviceId,\n      channelCount,\n      sampleRate: SAMPLE_RATE,\n      echoCancellation: false,\n      // TODO: add advanced controls for these options\n      // @ts-ignore (should be in type)\n      autoGainControl: false,\n      noiseSuppression: false,\n    },\n    video: false,\n  });\n  const audioContext = getRecordingAudioContext();\n  const mediaStreamSourceNode = audioContext.createMediaStreamSource(stream);\n  const { recorderNode, stop } = await createPcmRecorderNode({\n    channelCount,\n    onData,\n    onFinish,\n  });\n  mediaStreamSourceNode.connect(recorderNode);\n  recorderNode.connect(audioContext.destination);\n  onStart();\n\n  const timeLimitSeconds = 10;\n  const maxSamples = timeLimitSeconds * audioContext.sampleRate;\n  let samplesRecorded = 0;\n  /**\n   * @type {Float32Array[][]}\n   */\n  const recordedChunks = Array(channelCount).fill([]);\n\n  /**\n   * @param {Float32Array[]} audioChannels\n   */\n  function onData(audioChannels) {\n    /**\n     * @type {number}\n     */\n    let sampleCount = 0;\n    for (let channel = 0; channel < channelCount; channel++) {\n      const chunk = audioChannels[channel];\n      const chunkSize = chunk.length;\n      const chunkSliced = chunk.slice(\n        0,\n        Math.min(chunkSize, maxSamples - samplesRecorded)\n      );\n      // check for out-of-bounds values and just clip them (ideally we shouldn't\n      // have out-of-bounds values but this sometimes happens. by clipping them\n      // we kind of force the user to deal with the input levels.)\n      for (let i = 0; i < chunkSliced.length; i++) {\n        if (chunkSliced[i] > 1) {\n          chunkSliced[i] = 1;\n        } else if (chunkSliced[i] < -1) {\n          chunkSliced[i] = -1;\n        }\n      }\n      if (!sampleCount) {\n        sampleCount = chunkSliced.length;\n      }\n      recordedChunks[channel].push(chunkSliced);\n    }\n    samplesRecorded += sampleCount;\n    // should never be >, but just in case we did something wrong we use >=\n    if (samplesRecorded >= maxSamples) {\n      onFinish();\n      stop();\n    }\n  }\n\n  /**\n   * @type {(wavBuffer: Uint8Array) => void}\n   */\n  let onDone;\n  /**\n   * @type {(error: unknown) => void}\n   */\n  let onError;\n  /**\n   * @type {Promise<Uint8Array>}\n   */\n  const mediaRecording = new Promise((resolve, reject) => {\n    onDone = resolve;\n    onError = reject;\n  });\n  let finished = false;\n\n  function onFinish() {\n    if (finished) {\n      return;\n    }\n\n    // create wav file\n    try {\n      const samples = recordedChunks.map((chunks) => {\n        const merged = new Float32Array(\n          chunks.reduce((len, chunk) => len + chunk.length, 0)\n        );\n        let offset = 0;\n        for (const chunk of chunks) {\n          merged.set(chunk, offset);\n          offset += chunk.length;\n        }\n        return merged;\n      });\n      const wav = new WaveFile();\n      wav.fromScratch(samples.length, audioContext.sampleRate, '32f', samples);\n      onDone(wav.toBuffer());\n    } catch (err) {\n      onError(err);\n    }\n\n    // clean up\n    const tracks = stream.getTracks();\n    for (const track of tracks) {\n      track.stop();\n    }\n    recorderNode.disconnect(audioContext.destination);\n    mediaStreamSourceNode.disconnect(recorderNode);\n    finished = true;\n  }\n\n  return {\n    stop,\n    mediaRecording,\n  };\n}\n","import React, { useCallback, useEffect, useState } from 'react';\n\nimport { captureAudio, getAudioInputDevices } from './utils/recording';\n\n/**\n * @typedef {{\n *   onRecordStart: () => void;\n *   onRecordFinish: (wavBuffer: Uint8Array) => void;\n *   onRecordError: (err: unknown) => void;\n * }} MediaRecordingCallbacks\n */\n\n/**\n * @param {MediaRecordingCallbacks} callbacks\n */\nfunction useMediaRecording({ onRecordStart, onRecordFinish, onRecordError }) {\n  const [captureDevices, setCaptureDevices] = useState(\n    /** @type {Map<string, import('./utils/recording').AudioDeviceInfoContainer> | null} */ (\n      null\n    )\n  );\n  const [selectedCaptureDeviceId, setSelectedCaptureDeviceId] = useState('');\n  useEffect(() => {\n    getAudioInputDevices()\n      .then((devices) => devices.filter((d) => d.device.kind === 'audioinput'))\n      .then((devices) => {\n        if (devices.length) {\n          setCaptureDevices(\n            new Map(devices.map((d) => [d.device.deviceId, d]))\n          );\n          setSelectedCaptureDeviceId((id) => id || devices[0].device.deviceId);\n        }\n      });\n  }, []);\n  const [selectedChannelCount, setSelectedChannelCount] = useState(1);\n  useEffect(() => {\n    const selectedDeviceInfo =\n      captureDevices && captureDevices.get(selectedCaptureDeviceId);\n    if (selectedDeviceInfo) {\n      setSelectedChannelCount(selectedDeviceInfo.channelsAvailable);\n    }\n  }, [captureDevices, selectedCaptureDeviceId]);\n  const [recordingError, setRecordingError] = useState(\n    /** @type {Error | null} */ (null)\n  );\n  useEffect(() => {\n    if (recordingError) {\n      onRecordError(recordingError);\n    }\n  }, [recordingError, onRecordError]);\n  // to be set when recording is started\n  const [stop, setStop] = useState({ fn: () => {} });\n  const handleBeginRecording = useCallback(async () => {\n    const { mediaRecording, stop } = await captureAudio({\n      deviceId: selectedCaptureDeviceId,\n      channelCount: selectedChannelCount,\n      onStart: onRecordStart,\n    });\n    setStop({ fn: stop });\n    /**\n     * @type {Uint8Array}\n     */\n    let wavBuffer;\n    try {\n      wavBuffer = await mediaRecording;\n    } catch (err) {\n      setRecordingError(err);\n      return;\n    }\n    onRecordFinish(wavBuffer);\n  }, [\n    selectedCaptureDeviceId,\n    selectedChannelCount,\n    onRecordStart,\n    onRecordFinish,\n  ]);\n  return {\n    captureDevices,\n    selectedCaptureDeviceId,\n    selectedChannelCount,\n    recordingError,\n    setSelectedCaptureDeviceId,\n    setSelectedChannelCount,\n    beginRecording: handleBeginRecording,\n    stopRecording: stop.fn,\n  };\n}\n\n/**\n * @typedef {'ready' | 'capturing' | 'preparing' | 'error' | 'idle'} CaptureState\n */\n\n/**\n * @param {{ captureState: CaptureState } & MediaRecordingCallbacks} props\n */\nfunction SampleRecord({ captureState, ...callbacks }) {\n  const {\n    captureDevices,\n    selectedCaptureDeviceId,\n    selectedChannelCount,\n    recordingError,\n    setSelectedCaptureDeviceId,\n    setSelectedChannelCount,\n    beginRecording,\n    stopRecording,\n  } = useMediaRecording(callbacks);\n\n  if (captureState === 'idle') {\n    return null;\n  }\n\n  return (\n    <div style={{ paddingLeft: '2rem' }}>\n      {captureDevices ? (\n        <div>\n          <label>\n            Capture Device\n            <select\n              value={selectedCaptureDeviceId}\n              onChange={(e) => setSelectedCaptureDeviceId(e.target.value)}\n            >\n              {[...captureDevices].map(([id, { device }]) => (\n                <option key={id} value={id}>\n                  {device.label || id}\n                </option>\n              ))}\n            </select>\n          </label>\n          <label>\n            Channel count\n            <select\n              value={selectedChannelCount}\n              onChange={(e) => setSelectedChannelCount(Number(e.target.value))}\n            >\n              {[1, 2].map((count) => (\n                <option\n                  key={count}\n                  value={count}\n                  disabled={\n                    !captureDevices.has(selectedCaptureDeviceId) ||\n                    /** @type {import('./utils/recording').AudioDeviceInfoContainer} */ (\n                      captureDevices.get(selectedCaptureDeviceId)\n                    ).channelsAvailable < count\n                  }\n                >\n                  {count}\n                </option>\n              ))}\n            </select>\n          </label>\n        </div>\n      ) : (\n        'Loading capture devices...'\n      )}\n      <button\n        type=\"button\"\n        onClick={captureState === 'capturing' ? stopRecording : beginRecording}\n        disabled={captureState === 'preparing'}\n      >\n        {['capturing', 'preparing'].includes(captureState) ? 'Stop' : 'Record'}\n      </button>\n    </div>\n  );\n}\n\nexport default SampleRecord;\n","import React, { useCallback, useEffect, useState } from 'react';\n\nimport SampleList from './SampleList';\nimport SampleDetail from './SampleDetail';\nimport SampleRecord from './SampleRecord';\nimport { factorySamples, SampleContainer, storeWavSourceFile } from './store';\n\n{\n  const css = `\n.volcaSampler {\n  padding: 2rem;\n  display: flex;\n  height: 100%;\n}\n\n.sampleListContainer {\n  width: 200px;\n  flex-shrink: 0;\n  padding-right: 0.5rem;\n  height: 100%;\n}\n\n.focusedSampleContainer {\n  flex-grow: 1;\n}\n\n.focusedSample {\n  padding-left: 2rem;\n}\n  `;\n  const style = document.createElement('style');\n  style.innerHTML = css;\n  document.body.appendChild(style);\n}\n/**\n * @type {Record<string, string>}\n */\nconst classes = [\n  'volcaSampler',\n  'sampleListContainer',\n  'sampleList',\n  'sampleListItem',\n  'focusedSampleContainer',\n  'focusedSample',\n].reduce((classes, className) => ({ ...classes, [className]: className }), {});\n\nfunction App() {\n  const [showingFactorySamples, setShowingFactorySamples] = useState(false);\n  const [samples, setSamples] = useState(\n    /** @type {Map<string, SampleContainer>} */ (new Map())\n  );\n  const [focusedSampleId, setFocusedSampleId] = useState(\n    /** @type {string | null} */ (null)\n  );\n  const [loadingSamples, setLoadingSamples] = useState(true);\n  const [captureState, setCaptureState] = useState(\n    /** @type {import('./SampleRecord').CaptureState} */ ('idle')\n  );\n  const selectedSampleBank = showingFactorySamples ? factorySamples : samples;\n  useEffect(() => {\n    // TODO: error handling\n    SampleContainer.getAllFromStorage()\n      .then((storedSamples) => {\n        setSamples(\n          (samples) =>\n            new Map([\n              ...samples,\n              ...storedSamples.map(\n                (sample) =>\n                  /** @type {[string, SampleContainer]} */ ([sample.id, sample])\n              ),\n            ])\n        );\n        // TODO: automatically set focused sample id to first.. easier with useReducer maybe\n      })\n      .finally(() => {\n        setLoadingSamples(false);\n      });\n  }, []);\n  useEffect(() => {\n    if (\n      selectedSampleBank.size &&\n      !(focusedSampleId && selectedSampleBank.has(focusedSampleId))\n    ) {\n      setFocusedSampleId([...selectedSampleBank.values()][0].id);\n    }\n  }, [selectedSampleBank, focusedSampleId]);\n\n  const handleRecordStart = useCallback(() => setCaptureState('capturing'), []);\n\n  /**\n   * @type {(wavBuffer: Uint8Array) => void}\n   * */\n  const handleRecordFinish = useCallback(async (wavBuffer) => {\n    setCaptureState('preparing');\n    const id = await storeWavSourceFile(wavBuffer);\n    const sample = new SampleContainer.Mutable({\n      name: 'New one',\n      sourceFileId: id,\n    });\n    await sample.persist();\n    setSamples((samples) => new Map([[sample.id, sample], ...samples]));\n    setShowingFactorySamples(false);\n    setFocusedSampleId(sample.id);\n    setCaptureState('idle');\n  }, []);\n\n  /**\n   * @type {(err: unknown) => void}\n   * */\n  const handleRecordError = useCallback((err) => {\n    console.error(err);\n    setCaptureState('error');\n  }, []);\n\n  return (\n    <div className={classes.volcaSampler}>\n      <select\n        value={JSON.stringify(showingFactorySamples)}\n        onChange={(e) => setShowingFactorySamples(JSON.parse(e.target.value))}\n      >\n        <option value=\"false\">Your Samples</option>\n        <option value=\"true\">Factory Samples</option>\n      </select>\n      <div className={classes.sampleListContainer}>\n        <SampleList\n          samples={selectedSampleBank}\n          selectedSampleId={captureState === 'idle' ? focusedSampleId : null}\n          readonly={['capturing', 'preparing'].includes(captureState)}\n          onNewSample={() => setCaptureState('ready')}\n          onSampleSelect={(id) => {\n            setFocusedSampleId(id);\n            setCaptureState('idle');\n          }}\n        />\n      </div>\n      <div className={classes.focusedSampleContainer}>\n        {captureState === 'idle' && (\n          <SampleDetail\n            sample={\n              (focusedSampleId && selectedSampleBank.get(focusedSampleId)) ||\n              null\n            }\n            onSampleUpdate={(id, update) => {\n              const sample = selectedSampleBank.get(id);\n              if (sample && sample instanceof SampleContainer.Mutable) {\n                setSamples((samples) =>\n                  new Map(samples).set(sample.id, sample.update(update))\n                );\n              }\n            }}\n            onSampleDuplicate={(id) => {\n              const sample = selectedSampleBank.get(id);\n              if (sample) {\n                const newSample = sample.duplicate();\n                setSamples(\n                  (samples) => new Map([[newSample.id, newSample], ...samples])\n                );\n                setShowingFactorySamples(false);\n              }\n            }}\n            onSampleDelete={(id) => {\n              const sample = selectedSampleBank.get(id);\n              if (sample && sample instanceof SampleContainer.Mutable) {\n                sample.remove();\n                setSamples((samples) => {\n                  const newSamples = new Map(samples);\n                  newSamples.delete(sample.id);\n                  return newSamples;\n                });\n              }\n            }}\n          />\n        )}\n        <SampleRecord\n          captureState={captureState}\n          onRecordStart={handleRecordStart}\n          onRecordFinish={handleRecordFinish}\n          onRecordError={handleRecordError}\n        />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}