{"version":3,"sources":["SampleList.js","store.js","utils/constants.js","utils/audioData.js","Waveform.js","utils/getSyroBindings.js","utils/syro.js","SampleDetail.js","utils/recording.js","SampleRecord.js","App.js","reportWebVitals.js","index.js"],"names":[],"mappings":"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","file":"static/js/main.79ef1e7a.chunk.js","sourcesContent":["import React from 'react';\n\n{\n  const css = `\n.sampleList {\n  height: 100%;\n  overflow: auto;\n}\n\n.sampleListItem {\n  padding: 0.5rem;\n  border: 1px solid grey;\n  cursor: pointer;\n}\n\n.sampleListItem:not:nth-child(1) {\n  margin-top: 1rem;\n}\n  `;\n  const style = document.createElement('style');\n  style.innerHTML = css;\n  document.body.appendChild(style);\n}\n/**\n * @type {Record<string, string>}\n */\nconst classes = ['sampleList', 'sampleListItem'].reduce(\n  (classes, className) => ({ ...classes, [className]: className }),\n  {}\n);\n\n/**\n * @param {{\n *   samples: Map<string, import('./store').SampleContainer>;\n *   selectedSampleId: string | null;\n *   readonly: boolean;\n *   onNewSample: () => void;\n *   onSampleSelect: (id: string) => void;\n * }} props\n */\nfunction SampleList({ samples, selectedSampleId, readonly, onNewSample, onSampleSelect }) {\n  return (\n    <div className={classes.sampleList}>\n      <div\n        data-disabled={readonly}\n        className={classes.sampleListItem}\n        onClick={() => !readonly && onNewSample()}\n      >\n        New Sample\n      </div>\n      {[...samples].map(([id, sample]) => (\n        <div\n          key={id}\n          className={classes.sampleListItem}\n          style={{ backgroundColor: id === selectedSampleId ? '#f3f3f3' : undefined }}\n          data-disabled={readonly}\n          onClick={() => !readonly && onSampleSelect(id)}\n        >\n          <div>{sample.metadata.name}</div>\n          <div>\n            Updated {new Date(sample.metadata.dateModified).toLocaleString()}\n          </div>\n        </div>\n      ))}\n    </div>\n  );\n}\n\nexport default SampleList;\n","import localforage from 'localforage';\nimport { v4 as uuidv4 } from 'uuid';\n\nimport factorySampleParams from './factory-samples.json';\n\n/**\n * @typedef {object} SampleContainerParams\n * @property {string} name\n * @property {string} sourceFileId\n * @property {string} [id]\n * @property {number} [slotNumber]\n * @property {number} [dateSampled]\n * @property {number} [dateModified]\n * @property {boolean} [useCompression]\n * @property {number} [qualityBitDepth]\n * @property {number | false} [normalize]\n * @property {[number, number]} [clip]\n */\n\n/**\n * @typedef {object} SampleMetadata\n * @property {string} name\n * @property {string} sourceFileId\n * @property {number} slotNumber\n * @property {number} dateSampled\n * @property {number} dateModified\n * @property {boolean} useCompression\n * @property {number} qualityBitDepth\n * @property {number | false} normalize\n * @property {[number, number]} clip\n * @property {string} metadataVersion\n */\n\n/**\n * @typedef {object} SampleMetadataUpdate\n * @property {string} [name]\n * @property {number} [slotNumber]\n * @property {boolean} [useCompression]\n * @property {number} [qualityBitDepth]\n * @property {number | false} [normalize]\n * @property {[number, number]} [clip]\n */\n\nconst wavDataStore = localforage.createInstance({\n  name: 'wav_data',\n  driver: localforage.INDEXEDDB,\n});\n\nconst sampleMetadataStore = localforage.createInstance({\n  name: 'sample_metadata',\n  driver: localforage.INDEXEDDB,\n});\n\n/**\n * @param {Uint8Array} wavData\n * @returns {Promise<string>} id\n */\nexport async function storeWavSourceFile(wavData) {\n  const id = uuidv4();\n  await wavDataStore.setItem(id, wavData);\n  return id;\n}\n\nconst METADATA_VERSION = '0.1.0';\n\nexport class SampleContainer {\n  /**\n   * @param {SampleContainerParams} sampleContainerParams\n   */\n  constructor({\n    name,\n    sourceFileId,\n    id = uuidv4(),\n    slotNumber = 0,\n    dateSampled = Date.now(),\n    dateModified = dateSampled,\n    useCompression = false,\n    qualityBitDepth = 16,\n    normalize = false,\n    clip = [0, 0],\n  }) {\n    /** @readonly */\n    this.id = id;\n    /**\n     * @readonly\n     * @type {SampleMetadata}\n     */\n    this.metadata = {\n      name,\n      sourceFileId,\n      slotNumber,\n      dateSampled,\n      dateModified,\n      useCompression,\n      qualityBitDepth,\n      normalize,\n      clip,\n      metadataVersion: METADATA_VERSION,\n    };\n  }\n\n  /**\n   * @returns {SampleContainer}\n   */\n  duplicate() {\n    const copy = new SampleContainer.Mutable({\n      ...this.metadata,\n      name: `${this.metadata.name} (copy)`,\n      dateModified: Date.now(),\n    });\n    // async - does not block\n    copy.persist();\n    return copy;\n  }\n\n  static Mutable = class extends SampleContainer {\n    /**\n     * @param {SampleContainerParams} sampleContainerParams\n     */\n    constructor(sampleContainerParams) {\n      super(sampleContainerParams);\n      setTimeout(async () => {\n        const ids = await sampleMetadataStore.keys();\n        if (!ids.includes(this.id)) {\n          console.warn(\n            `Expected sample metadata container ${this.id} to be persisted`\n          );\n        }\n      });\n    }\n\n    async persist() {\n      await sampleMetadataStore.setItem(this.id, this.metadata);\n    }\n\n    /**\n     * @param {SampleMetadataUpdate} update\n     * @returns {SampleContainer}\n     */\n    update(update) {\n      const { id, metadata } = this;\n      /**\n       * @type {SampleMetadata}\n       */\n      const newMetadata = {\n        ...metadata,\n        ...update,\n        dateModified: Date.now(),\n      };\n      const newContainer = new SampleContainer.Mutable({ id, ...newMetadata });\n      // async - does not block\n      newContainer.persist();\n      return newContainer;\n    }\n\n    async remove() {\n      await sampleMetadataStore.removeItem(this.id);\n    }\n  };\n\n  /**\n   * @private\n   * @type {Map<string, Uint8Array>}\n   */\n  static sourceFileData = new Map();\n\n  /**\n   * @private\n   * @type {string[]}\n   */\n  static recentlyCachedSourceFileIds = [];\n\n  /** @readonly @private */\n  static MAX_CACHED = 10;\n\n  /**\n   * @param {string} sourceFileId\n   * @param {Uint8Array} data\n   */\n  static cacheSourceFileData(sourceFileId, data) {\n    this.sourceFileData.set(sourceFileId, data);\n    this.recentlyCachedSourceFileIds = [\n      sourceFileId,\n      ...this.recentlyCachedSourceFileIds.filter((id) => id !== sourceFileId),\n    ];\n    const stale = this.recentlyCachedSourceFileIds.slice(this.MAX_CACHED);\n    for (const sourceFileId of stale) {\n      this.sourceFileData.delete(sourceFileId);\n    }\n    this.recentlyCachedSourceFileIds = this.recentlyCachedSourceFileIds.slice(\n      0,\n      this.MAX_CACHED\n    );\n  }\n\n  /**\n   * @param {string} sourceFileId\n   * @returns {Promise<Uint8Array>}\n   */\n  static async getSourceFileData(sourceFileId) {\n    {\n      const data = this.sourceFileData.get(sourceFileId);\n      if (data) {\n        return data;\n      }\n    }\n    if (sourceFileId.includes('.')) {\n      // assume it's a URL pointing to a WAV file\n      const buffer = await (await fetch(sourceFileId)).arrayBuffer();\n      const data = new Uint8Array(buffer);\n      this.cacheSourceFileData(sourceFileId, data);\n      return data;\n    }\n    /**\n     * @type {unknown}\n     */\n    const data = await wavDataStore.getItem(sourceFileId);\n    if (data) {\n      if (data instanceof Uint8Array) {\n        this.cacheSourceFileData(sourceFileId, data);\n        return data;\n      }\n      return Promise.reject('Source data is of unexpected type');\n    }\n    return Promise.reject('Missing source data');\n  }\n\n  static async getAllFromStorage() {\n    /**\n     * @type {Map<string, SampleMetadata>}\n     */\n    const sampleMetadata = new Map();\n    await sampleMetadataStore.iterate((metadata, id) => {\n      if (metadata && metadata.metadataVersion === METADATA_VERSION) {\n        sampleMetadata.set(id, metadata);\n      } else {\n        // TODO: handle upgrade\n        console.warn(\n          `Found metadata \"${metadata.name || id} with unhandled version ${\n            metadata.metadataVersion\n          }\"; ignoring.`\n        );\n      }\n    });\n    const sourceIds = (await wavDataStore.keys()).concat(\n      factorySampleParams.map(({ sourceFileId }) => sourceFileId)\n    );\n    const sampleContainers = /** @type {SampleContainer[]} */ (\n      [...sampleMetadata]\n        .map(([id, metadata]) => {\n          const { sourceFileId } = metadata;\n          if (!sourceIds.includes(sourceFileId)) {\n            console.warn(\n              `Found metadata \"${\n                metadata.name || id\n              }\" with missing data \"${sourceFileId}; ignoring.`\n            );\n            return null;\n          }\n          return new SampleContainer.Mutable({ id, ...metadata });\n        })\n        .filter(Boolean)\n    ).sort((a, b) => b.metadata.dateModified - a.metadata.dateModified);\n    return sampleContainers;\n  }\n}\n\nexport const factorySamples = new Map(\n  factorySampleParams.map((params) => [params.id, new SampleContainer(params)])\n);\n","export const SAMPLE_RATE = 31250;\n","import getWavFileHeaders from 'wav-headers';\n\nimport { SampleContainer } from '../store';\nimport { SAMPLE_RATE } from './constants';\n\n/**\n * @param {AudioBuffer} sourceAudioBuffer\n * @returns {Promise<AudioBuffer>}\n */\nasync function resampleToTargetSampleRate(sourceAudioBuffer) {\n  if (sourceAudioBuffer.sampleRate === SAMPLE_RATE) {\n    return sourceAudioBuffer;\n  }\n  const ratio = SAMPLE_RATE / sourceAudioBuffer.sampleRate;\n  const offlineContext = new OfflineAudioContext(\n    sourceAudioBuffer.numberOfChannels,\n    sourceAudioBuffer.length * ratio,\n    SAMPLE_RATE\n  );\n  const offlineSource = offlineContext.createBufferSource();\n  offlineSource.buffer = sourceAudioBuffer;\n  offlineSource.connect(offlineContext.destination);\n  offlineSource.start();\n  const audioBufferResampled = await offlineContext.startRendering();\n  return audioBufferResampled;\n}\n\n/**\n * @param {Float32Array} array\n * @param {[number, number]} clipFrames\n */\nfunction getClippedView(array, clipFrames) {\n  const frameSizeInBytes = 4;\n  const byteOffset = clipFrames[0] * frameSizeInBytes;\n  const viewLength = array.length - clipFrames[0] - clipFrames[1];\n  return new Float32Array(array.buffer, byteOffset, viewLength);\n}\n\n/**\n * @param {AudioBuffer} audioBuffer\n * @param {[number, number]} clipFrames\n */\nexport function getMonoSamplesFromAudioBuffer(audioBuffer, clipFrames) {\n  const clippedLength = audioBuffer.length - clipFrames[0] - clipFrames[1];\n  const samples = new Float32Array(clippedLength);\n  const channels = /** @type {void[]} */ (Array(audioBuffer.numberOfChannels))\n    .fill()\n    .map((_, i) => getClippedView(audioBuffer.getChannelData(i), clipFrames));\n  for (let i = 0; i < clippedLength; i++) {\n    let monoSample = 0;\n    for (let j = 0; j < channels.length; j++) {\n      monoSample += channels[j][i];\n    }\n    monoSample /= channels.length;\n    samples[i] = monoSample;\n  }\n  return samples;\n}\n\n/**\n * Finds most significant magnitude in array of samples.\n * @param {Float32Array} samples array of floats between -1 and 1\n * @returns {number} peak value between 0 and 1\n */\nexport function findSamplePeak(samples) {\n  let peak = 0;\n  for (const sample of samples) {\n    const abs = Math.abs(sample);\n    if (abs > peak) {\n      peak = abs;\n    }\n  }\n  return peak;\n}\n\n/**\n * Scales an array of samples according to a specified coefficient.\n * Note: mutates input array (no return value).\n * @param {Float32Array} samples array of floats\n * @param {number} coef float value to multiply against each sample\n */\nfunction scaleSamples(samples, coef) {\n  if (coef !== 1) {\n    for (let i = 0; i < samples.length; i++) {\n      samples[i] *= coef;\n    }\n  }\n}\n\n/**\n * Normalizes samples by adjusting max value to 1 and scaling others by same\n * coefficient. Note: mutates input array (no return value).\n * @param {Float32Array} samples array of floats between -1 and 1\n * @param {number} peakTarget float between 0 and 1\n */\nfunction normalizeSamples(samples, peakTarget = 1) {\n  const coef = peakTarget / findSamplePeak(samples);\n  scaleSamples(samples, coef);\n}\n\n/**\n * Reduces precision of samples by converting them to integers of a given bit\n * depth then back to floats. Note: mutates input array (no return value).\n * @param {Float32Array} samples array of floats between -1 and 1\n * @param {number} qualityBitDepth number from 8 to 16\n */\nfunction applyQualityBitDepthToSamples(samples, qualityBitDepth) {\n  const signedMax = 2 ** (qualityBitDepth - 1);\n  for (let i = 0; i < samples.length; i++) {\n    samples[i] = Math.round(samples[i] * signedMax) / signedMax;\n  }\n}\n\n/**\n * @param {Float32Array} samples\n */\nfunction convertSamplesTo16Bit(samples) {\n  const samples16 = new Int16Array(samples.length);\n  const signedMax = 2 ** 15;\n  for (let i = 0; i < samples.length; i++) {\n    samples16[i] = samples[i] === 1 ? signedMax - 1 : signedMax * samples[i];\n  }\n  return samples16;\n}\n\n/**\n * @type {AudioContext | undefined}\n */\nlet targetAudioContext;\n\nfunction getTargetAudioContext() {\n  return (targetAudioContext =\n    targetAudioContext || new AudioContext({ sampleRate: SAMPLE_RATE }));\n}\n\n/**\n * @param {Uint8Array} audioFileBuffer audio file to transform into audio buffer\n * @returns {Promise<AudioBuffer>}\n */\nexport async function getAudioBufferForAudioFileData(audioFileBuffer) {\n  // make a copy of the data (since decodeAudioData will empty the source array)\n  const bufferCopy = new Uint8Array(audioFileBuffer);\n  /**\n   * @type {AudioBuffer}\n   */\n  const audioBuffer = await new Promise((resolve, reject) => {\n    getTargetAudioContext().decodeAudioData(bufferCopy.buffer, resolve, reject);\n  });\n  return audioBuffer;\n}\n\n/**\n * @param {import('../store').SampleContainer} sampleContainer\n * @returns {Promise<{ data: Uint8Array; sampleRate: number }>}\n */\nexport async function convertWavTo16BitMono(sampleContainer) {\n  const { qualityBitDepth, normalize, clip } = sampleContainer.metadata;\n  if (\n    qualityBitDepth < 8 ||\n    qualityBitDepth > 16 ||\n    !Number.isInteger(qualityBitDepth)\n  ) {\n    throw new Error(\n      `Expected bit depth between 8 and 16. Received: ${qualityBitDepth}`\n    );\n  }\n  const wavSrcAudioBuffer = await resampleToTargetSampleRate(\n    await getAudioBufferForAudioFileData(\n      await SampleContainer.getSourceFileData(\n        sampleContainer.metadata.sourceFileId\n      )\n    )\n  );\n  const clipFrames = /** @type {[number, number]} */ (\n    clip.map((c) => Math.round(c * wavSrcAudioBuffer.sampleRate))\n  );\n  const samples =\n    wavSrcAudioBuffer.numberOfChannels === 1\n      ? getClippedView(wavSrcAudioBuffer.getChannelData(0), clipFrames)\n      : getMonoSamplesFromAudioBuffer(wavSrcAudioBuffer, clipFrames);\n  if (normalize) {\n    normalizeSamples(samples, normalize);\n  }\n  if (qualityBitDepth < 16) {\n    applyQualityBitDepthToSamples(samples, qualityBitDepth);\n  }\n  const samples16 = convertSamplesTo16Bit(samples);\n  const samplesByteLength = samples16.length * 2;\n  /**\n   * @type {Uint8Array}\n   */\n  const wavHeader = getWavFileHeaders({\n    channels: 1,\n    sampleRate: wavSrcAudioBuffer.sampleRate,\n    bitDepth: 16,\n    dataLength: samplesByteLength,\n  });\n  const wavBuffer = new Uint8Array(wavHeader.length + samplesByteLength);\n  wavBuffer.set(wavHeader);\n  wavBuffer.set(new Uint8Array(samples16.buffer), wavHeader.length);\n  return {\n    data: wavBuffer,\n    sampleRate: 16,\n  };\n}\n","import React, { useEffect, useMemo, useRef, useState } from 'react';\n\nimport {\n  getAudioBufferForAudioFileData,\n  getMonoSamplesFromAudioBuffer,\n  findSamplePeak,\n} from './utils/audioData';\nimport { SampleContainer } from './store';\n\n/**\n * @param {Float32Array} samples an array of floats from -1 to 1\n * @param {number} groupSize the number of samples represented for each peak\n * @returns {{\n *   positive: Float32Array;\n *   negative: Float32Array;\n * }} arrays of peak positive and negative values\n */\nfunction getPeaksForSamples(samples, groupSize) {\n  // Cut off whatever's left after dividing into blocks of length [groupSize]\n  const positive = new Float32Array(Math.floor(samples.length / groupSize));\n  const negative = new Float32Array(Math.floor(samples.length / groupSize));\n  for (let i = 0; i < positive.length; i++) {\n    const group = new Float32Array(\n      samples.buffer,\n      i * groupSize * 4,\n      groupSize\n    );\n    let max = 0;\n    let min = 0;\n    for (const sample of group) {\n      if (sample > max) {\n        max = sample;\n      }\n      if (sample < min) {\n        min = sample;\n      }\n    }\n    positive[i] = max;\n    negative[i] = min;\n  }\n  return { positive, negative };\n}\n\n/**\n * @param {{\n *   sample: import('./store').SampleContainer;\n *   onSetClip: (clip: [number, number]) => void;\n *   onSetNormalize: (normalize: number | false) => void;\n * }} props\n */\nfunction Waveform({ sample, onSetClip, onSetNormalize }) {\n  const [monoSamples, setMonoSamples] = useState(new Float32Array());\n  useEffect(() => {\n    let cancelled = false;\n    (async () => {\n      if (cancelled) return;\n      const fileData = await SampleContainer.getSourceFileData(\n        sample.metadata.sourceFileId\n      );\n      if (cancelled) return;\n      const audioBuffer = await getAudioBufferForAudioFileData(fileData);\n      if (cancelled) return;\n      const monoSamples = getMonoSamplesFromAudioBuffer(audioBuffer, [0, 0]);\n      setMonoSamples(monoSamples);\n    })();\n    return () => {\n      cancelled = true;\n    };\n  }, [sample.metadata.sourceFileId]);\n\n  /**\n   * @type {React.RefObject<HTMLDivElement>}\n   */\n  const ref = useRef(null);\n  const groupWidth = 6;\n  const peaks = useMemo(() => {\n    const pixelWidth = ref.current && ref.current.offsetWidth;\n    if (!pixelWidth || !monoSamples.length) {\n      return {\n        positive: new Float32Array(),\n        negative: new Float32Array(),\n      };\n    }\n    const groupSize = Math.floor(\n      (groupWidth * monoSamples.length) / pixelWidth\n    );\n    return getPeaksForSamples(monoSamples, groupSize);\n  }, [monoSamples]);\n  const samplePeak = useMemo(\n    () =>\n      Math.max(findSamplePeak(peaks.negative), findSamplePeak(peaks.positive)),\n    [peaks]\n  );\n  const peakTarget = sample.metadata.normalize || samplePeak;\n  const scaleCoefficient = peakTarget / samplePeak;\n\n  return (\n    <div\n      className=\"waveform\"\n      style={{\n        width: '100%',\n        height: '100%',\n        position: 'relative',\n        overflow: 'hidden',\n      }}\n      ref={ref}\n    >\n      <div\n        className=\"positive\"\n        style={{\n          width: '100%',\n          height: '67%',\n          display: 'flex',\n          alignItems: 'flex-end',\n        }}\n      >\n        <div\n          className=\"scaled\"\n          style={{\n            width: '100%',\n            height: `${100 * scaleCoefficient}%`,\n            willChange: 'height',\n            display: 'flex',\n            alignItems: 'flex-end',\n          }}\n        >\n          {[].map.call(peaks.positive, (amplitude, index) => (\n            <div\n              key={index}\n              className=\"bar\"\n              style={{\n                width: groupWidth,\n                height: `${100 * amplitude}%`,\n                paddingRight: 1,\n              }}\n            >\n              <div\n                className=\"bar_inner\"\n                style={{ backgroundColor: 'red', height: '100%' }}\n              />\n            </div>\n          ))}\n        </div>\n      </div>\n      <div\n        className=\"negative\"\n        style={{\n          width: '100%',\n          height: '33%',\n          display: 'flex',\n          alignItems: 'flex-start',\n        }}\n      >\n        <div\n          className=\"scaled\"\n          style={{\n            width: '100%',\n            height: `${100 * scaleCoefficient}%`,\n            willChange: 'height',\n            display: 'flex',\n            alignItems: 'flex-start',\n          }}\n        >\n          {[].map.call(peaks.negative, (amplitude, index) => (\n            <div\n              key={index}\n              className=\"bar\"\n              style={{\n                width: groupWidth,\n                height: `${100 * -amplitude}%`,\n                paddingRight: 1,\n              }}\n            >\n              <div\n                className=\"bar_inner\"\n                style={{ backgroundColor: 'darkred', height: '100%' }}\n              />\n            </div>\n          ))}\n        </div>\n      </div>\n      <input\n        style={{ position: 'absolute', top: 0, left: 0 }}\n        type=\"range\"\n        value={sample.metadata.normalize || undefined}\n        min={0.1}\n        max={1}\n        step={0.01}\n        onChange={(e) => onSetNormalize(Number(e.target.value))}\n      />\n    </div>\n  );\n}\n\nexport default Waveform;\n","// @ts-nocheck\n\n/**\n * @typedef {{\n *   prepareSampleBufferFromWavData: (\n *     wavData: Uint8Array,\n *     bytes: number,\n *     slotNumber: number,\n *     quality: number,\n *     useCompression: 0 | 1\n *   ) => number;\n *   prepareSampleBufferFrom16BitPcmData(\n *     wavData: Uint8Array,\n *     bytes: number,\n *     rate: number,\n *     slotNumber: number,\n *     quality: number,\n *     useCompression: 0 | 1\n *   ) => number;\n *   startSampleBufferFrom16BitPcmData(\n *     wavData: Uint8Array,\n *     bytes: number,\n *     rate: number,\n *     slotNumber: number,\n *     quality: number,\n *     useCompression: 0 | 1\n *   ) => number;\n *   iterateSampleBuffer: (iterations: number) => void;\n *   getSampleBufferPointer: () => number;\n *   getSampleBufferSize: () => number;\n *   getSampleBufferProgress: () => number;\n *   freeSampleBuffer: () => void;\n *   heap8Buffer: () => ArrayBuffer;\n * }} SyroBindings\n */\n\n/**\n * @type {Promise<SyroBindings> | undefined}\n */\nlet syroBindingsPromise;\n\nexport async function getSyroBindings() {\n  if (typeof window.CREATE_SYRO_BINDINGS !== 'function') {\n    return Promise.reject(\n      'Expected CREATE_SYRO_BINDINGS global function to exist'\n    );\n  }\n  const Module = await window.CREATE_SYRO_BINDINGS();\n  return (syroBindingsPromise =\n    syroBindingsPromise ||\n    new Promise((resolve, reject) => {\n      /**\n       * @type {SyroBindings}\n       */\n      let syroBindings;\n      try {\n        syroBindings = {\n          prepareSampleBufferFromWavData: Module.cwrap(\n            'prepareSampleBufferFromWavData',\n            'number',\n            ['array', 'number', 'number', 'number']\n          ),\n          prepareSampleBufferFrom16BitPcmData: Module.cwrap(\n            'prepareSampleBufferFrom16BitPcmData',\n            'number',\n            ['array', 'number', 'number', 'number', 'number']\n          ),\n          startSampleBufferFrom16BitPcmData: Module.cwrap(\n            'startSampleBufferFrom16BitPcmData',\n            'number',\n            ['array', 'number', 'number', 'number', 'number']\n          ),\n          iterateSampleBuffer: Module.cwrap('iterateSampleBuffer', null, [\n            'number',\n          ]),\n          getSampleBufferPointer: Module.cwrap(\n            'getSampleBufferPointer',\n            'number',\n            []\n          ),\n          getSampleBufferSize: Module.cwrap(\n            'getSampleBufferSize',\n            'number',\n            []\n          ),\n          getSampleBufferProgress: Module.cwrap(\n            'getSampleBufferProgress',\n            'number',\n            []\n          ),\n          freeSampleBuffer: Module.cwrap('freeSampleBuffer', null, []),\n          heap8Buffer() {\n            return Module.HEAP8.buffer;\n          },\n        };\n      } catch (err) {\n        reject(err);\n        return;\n      }\n      resolve(syroBindings);\n    }));\n}\n","import { getSyroBindings } from './getSyroBindings';\nimport { convertWavTo16BitMono } from './audioData';\n\n/**\n * @param {import('../store').SampleContainer} sampleContainer\n * @param {(progress: number) => void} onProgress\n * @returns {Promise<Uint8Array>}\n */\nexport async function getSampleBuffer(sampleContainer, onProgress) {\n  const {\n    startSampleBufferFrom16BitPcmData,\n    iterateSampleBuffer,\n    getSampleBufferPointer,\n    getSampleBufferSize,\n    getSampleBufferProgress,\n    freeSampleBuffer,\n    heap8Buffer,\n  } = await getSyroBindings();\n  const { data, sampleRate } = await convertWavTo16BitMono(sampleContainer);\n  const pcmData = data.slice(44);\n  const err = startSampleBufferFrom16BitPcmData(\n    pcmData,\n    pcmData.length,\n    sampleRate,\n    sampleContainer.metadata.slotNumber,\n    sampleContainer.metadata.qualityBitDepth,\n    sampleContainer.metadata.useCompression ? 1 : 0\n  );\n  if (err) {\n    return Promise.reject('Failed to prepare sample buffer');\n  }\n  const bufferPointer = getSampleBufferPointer();\n  const bufferSize = getSampleBufferSize();\n  const resultView = new Uint8Array(heap8Buffer(), bufferPointer, bufferSize);\n  onProgress(getSampleBufferProgress() / bufferSize);\n  await /** @type {Promise<void>} */ (\n    new Promise((resolve, reject) => {\n      const targetIterationTime = 10;\n      // assume we're behind at the start, to avoid starting with a long frame\n      let lastTime = targetIterationTime * 2;\n      let lastIterationInterval = 100_000;\n      requestAnimationFrame(iterate);\n      function iterate() {\n        if (getSampleBufferProgress() >= bufferSize) {\n          resolve();\n          return;\n        }\n        const correctionCoefficient = targetIterationTime / lastTime;\n        const iterationInterval = Math.max(\n          Math.round(lastIterationInterval * correctionCoefficient),\n          1\n        );\n        const before = performance.now();\n        try {\n          iterateSampleBuffer(iterationInterval);\n        } catch (err) {\n          reject(err);\n          return;\n        }\n        lastTime = performance.now() - before;\n        if (lastTime === 0) {\n          // to avoid divide-by-zero due to potential rounding in Firefox\n          // https://developer.mozilla.org/en-US/docs/Web/API/Performance/now#reduced_time_precision\n          lastTime = 0.5;\n        }\n        lastIterationInterval = iterationInterval;\n        onProgress(getSampleBufferProgress() / bufferSize);\n        requestAnimationFrame(iterate);\n      }\n    })\n  );\n  // save a new copy of the data before freeing the result\n  const sampleBuffer = new Uint8Array(resultView);\n  freeSampleBuffer();\n  return sampleBuffer;\n}\n","import React from 'react';\n\nimport Waveform from './Waveform';\nimport { SampleContainer } from './store';\nimport { convertWavTo16BitMono } from './utils/audioData';\nimport { getSampleBuffer } from './utils/syro';\n\n{\n  const css = `\n.sampleDetail {\n  padding-left: 2rem;\n}\n  `;\n  const style = document.createElement('style');\n  style.innerHTML = css;\n  document.body.appendChild(style);\n}\n/**\n * @type {Record<string, string>}\n */\nconst classes = ['sampleDetail'].reduce(\n  (classes, className) => ({ ...classes, [className]: className }),\n  {}\n);\n\n/**\n * @param {Uint8Array} audioFileBuffer audio file to transform into audio buffer\n */\n export function playAudioFile(audioFileBuffer) {\n  const blob = new Blob([audioFileBuffer], {\n    type: 'audio/x-wav',\n  });\n  const audioElement = document.createElement('audio');\n  audioElement.src = URL.createObjectURL(blob);\n  audioElement.play();\n  audioElement.onended = () => {\n    URL.revokeObjectURL(audioElement.src);\n  };\n}\n\n/**\n * @param {{\n *   sample: SampleContainer | null;\n *   onSampleUpdate: (id: string, update: import('./store').SampleMetadataUpdate) => void;\n *   onSampleDuplicate: (id: string) => void;\n *   onSampleDelete: (id: string) => void;\n * }} props\n */\nfunction SampleDetail({\n  sample,\n  onSampleUpdate,\n  onSampleDuplicate,\n  onSampleDelete,\n}) {\n  if (!sample) {\n    return null;\n  }\n  return (\n    <div className={classes.sampleDetail}>\n      <h3>{sample.metadata.name}</h3>\n      <button type=\"button\" onClick={() => onSampleDuplicate(sample.id)}>\n        Duplicate\n      </button>\n      <button\n        type=\"button\"\n        onClick={() => {\n          if (\n            window.confirm(\n              `Are you sure you want to delete ${sample.metadata.name}?`\n            )\n          ) {\n            onSampleDelete(sample.id);\n          }\n        }}\n      >\n        Remove\n      </button>\n      <h4>\n        Last edited: {new Date(sample.metadata.dateModified).toLocaleString()}\n      </h4>\n      <h4>Sampled: {new Date(sample.metadata.dateSampled).toLocaleString()}</h4>\n      <label>\n        <h4>Clip start</h4>\n        <input\n          type=\"number\"\n          value={sample.metadata.clip[0]}\n          step={0.1}\n          min={0}\n          onChange={(e) => {\n            const clipStart = Number(e.target.value);\n            onSampleUpdate(sample.id, {\n              clip: [clipStart, sample.metadata.clip[1]],\n            });\n          }}\n        />\n      </label>\n      <label>\n        <h4>Clip end</h4>\n        <input\n          type=\"number\"\n          value={sample.metadata.clip[1]}\n          step={0.1}\n          min={0}\n          onChange={(e) => {\n            const clipEnd = Number(e.target.value);\n            onSampleUpdate(sample.id, {\n              clip: [sample.metadata.clip[0], clipEnd],\n            });\n          }}\n        />\n      </label>\n      <div\n        style={{\n          height: 200,\n          backgroundColor: '#f3f3f3',\n          maxWidth: 400,\n        }}\n      >\n        <Waveform\n          onSetClip={() => null}\n          onSetNormalize={(normalize) =>\n            onSampleUpdate(sample.id, { normalize })\n          }\n          sample={sample}\n        />\n        <button\n          type=\"button\"\n          disabled={sample.metadata.normalize === 1}\n          onClick={() => onSampleUpdate(sample.id, { normalize: 1 })}\n        >\n          Normalize\n        </button>\n        <button\n          type=\"button\"\n          disabled={!sample.metadata.normalize}\n          onClick={() => onSampleUpdate(sample.id, { normalize: false })}\n        >\n          Original level\n        </button>\n        <button\n          type=\"button\"\n          onClick={async () => {\n            const { data } = await convertWavTo16BitMono(sample);\n            playAudioFile(data);\n          }}\n        >\n          regular play\n        </button>\n        <button\n          type=\"button\"\n          onClick={async () => {\n            const { data } = await convertWavTo16BitMono(sample);\n            const blob = new Blob([data], {\n              type: 'audio/x-wav',\n            });\n            const url = URL.createObjectURL(blob);\n            const a = document.createElement('a');\n            a.href = url;\n            a.download = `${sample.metadata.name}.wav`;\n            a.style.display = 'none';\n            document.body.appendChild(a);\n            a.click();\n            a.remove();\n            URL.revokeObjectURL(url);\n          }}\n        >\n          download\n        </button>\n      </div>\n      <h4>Quality bit depth: {sample.metadata.qualityBitDepth}</h4>\n      <input\n        type=\"range\"\n        value={sample.metadata.qualityBitDepth}\n        step={1}\n        min={8}\n        max={16}\n        onChange={(e) => {\n          const qualityBitDepth = Number(e.target.value);\n          onSampleUpdate(sample.id, { qualityBitDepth });\n        }}\n      />\n      <label>\n        <h4>Slot number</h4>\n        <input\n          type=\"number\"\n          value={sample.metadata.slotNumber}\n          step={1}\n          min={0}\n          max={99}\n          onChange={(e) => {\n            const slotNumber = Number(e.target.value);\n            onSampleUpdate(sample.id, { slotNumber });\n          }}\n        />\n      </label>\n      <button\n        type=\"button\"\n        onClick={async () => {\n          try {\n            const sampleBuffer = await getSampleBuffer(sample, console.log);\n            playAudioFile(sampleBuffer);\n          } catch (err) {\n            console.error(err);\n          }\n        }}\n      >\n        transfer to volca sample\n      </button>\n    </div>\n  );\n}\n\nexport default SampleDetail;\n","import { WaveFile } from 'wavefile';\n\nimport { SAMPLE_RATE } from './constants';\n\n/**\n * @type {AudioContext | undefined}\n */\nlet recordingAudioContext;\n\nfunction getRecordingAudioContext() {\n  return (recordingAudioContext =\n    recordingAudioContext ||\n    new AudioContext(\n      navigator.mediaDevices.getSupportedConstraints().sampleRate\n        ? { sampleRate: SAMPLE_RATE }\n        : {}\n    ));\n}\n\n/**\n * @typedef {{ device: { deviceId: string; label: string }; channelsAvailable: number }} AudioDeviceInfoContainer\n */\n\n/**\n * @returns {Promise<AudioDeviceInfoContainer[]>}\n */\nexport async function getAudioInputDevices() {\n  const devices = await navigator.mediaDevices.enumerateDevices();\n  const audioInputDevices = devices.filter(\n    (device) => device.kind === 'audioinput'\n  );\n  /**\n   * @type {AudioDeviceInfoContainer[]}\n   */\n  const infoContainers = [];\n  for (const device of audioInputDevices) {\n    const stream = await navigator.mediaDevices.getUserMedia({\n      // try to grab stereo audio\n      audio: { deviceId: device.deviceId, channelCount: 2 },\n      video: false,\n    });\n    // for Firefox, which requires us to check this info after\n    // permissions have been granted\n    const realLabel = /** @type {MediaDeviceInfo} */ (\n      (await navigator.mediaDevices.enumerateDevices()).find(\n        ({ deviceId }) => device.deviceId === deviceId\n      )\n    ).label;\n    // TODO: validate this is the right way to get the channel count..\n    // maybe we have to wait for data available or something else?\n    const channelsAvailable = stream.getAudioTracks().length;\n    for (const track of stream.getTracks()) {\n      track.stop();\n    }\n    infoContainers.push({\n      device: { deviceId: device.deviceId, label: realLabel },\n      channelsAvailable,\n    });\n  }\n  return infoContainers;\n}\n\n/**\n * @typedef {Omit<AudioWorkletNode, 'parameters'> & {\n *   parameters: Map<'isRecording' | 'bufferSize', AudioParam>\n * }} TAudioWorkletNode\n */\n\n/**\n * @typedef {{\n *  channelCount: number;\n *  onData: (audioChannels: Float32Array[]) => void;\n *  onFinish: () => void;\n * }} PcmRecorderNodeOptions\n */\n\n/**\n * @type {Promise<void> | undefined}\n */\nlet recorderWorkletProcessorPromise;\n/**\n * @param {PcmRecorderNodeOptions} options\n * @returns {Promise<{ recorderNode: TAudioWorkletNode; stop: () => void }>}\n */\nasync function createAudioWorkletPcmRecorderNode({ onData, onFinish }) {\n  const audioContext = getRecordingAudioContext();\n  recorderWorkletProcessorPromise =\n    recorderWorkletProcessorPromise ||\n    audioContext.audioWorklet.addModule('recorderWorkletProcessor.js');\n  await recorderWorkletProcessorPromise;\n  const recorderNode = /** @type {TAudioWorkletNode} */ (\n    new AudioWorkletNode(audioContext, 'recorder-worklet', {\n      parameterData: {\n        bufferSize: 1024,\n      },\n    })\n  );\n  recorderNode.port.onmessage = (e) => {\n    if (e.data.eventType === 'data') {\n      /**\n       * @type {Float32Array[]}\n       */\n      const audioChannels = e.data.audioChannels;\n      onData(audioChannels);\n    }\n\n    if (e.data.eventType === 'stop') {\n      onFinish();\n    }\n  };\n  const isRecordingParam = /** @type {AudioParam} */ (\n    recorderNode.parameters.get('isRecording')\n  );\n  isRecordingParam.setValueAtTime(1, audioContext.currentTime);\n  return {\n    recorderNode,\n    stop() {\n      isRecordingParam.setValueAtTime(0, audioContext.currentTime);\n    },\n  };\n}\n\n/**\n * @param {PcmRecorderNodeOptions} options\n * @returns {{ recorderNode: ScriptProcessorNode; stop: () => void }}\n */\nfunction createScriptProcessorPcmRecorderNode({\n  channelCount,\n  onData,\n  onFinish,\n}) {\n  const audioContext = getRecordingAudioContext();\n  const recorderNode = audioContext.createScriptProcessor(\n    1024,\n    channelCount,\n    channelCount\n  );\n  // to be set by user if they want to stop recording before time limit reached\n  let stopped = false;\n  recorderNode.onaudioprocess = (e) => {\n    const audioChannels = /** @type {void[]} */ (Array(channelCount))\n      .fill()\n      .map((_, i) => e.inputBuffer.getChannelData(i));\n    onData(audioChannels);\n    if (stopped) {\n      onFinish();\n    }\n  };\n  return {\n    recorderNode,\n    stop() {\n      stopped = true;\n    },\n  };\n}\n\n/**\n * @param {PcmRecorderNodeOptions} options\n * @returns {Promise<{ recorderNode: AudioNode; stop: () => void }>}\n */\nasync function createPcmRecorderNode(options) {\n  if (typeof AudioWorkletNode === 'undefined') {\n    return createScriptProcessorPcmRecorderNode(options);\n  }\n  return await createAudioWorkletPcmRecorderNode(options);\n}\n\n/**\n * @param {{\n *   deviceId: string;\n *   channelCount: number;\n *   onStart: () => void;\n * }} options\n * @returns {Promise<{ mediaRecording: Promise<Uint8Array>; stop: () => void }>}\n */\nexport async function captureAudio({ deviceId, channelCount, onStart }) {\n  const stream = await navigator.mediaDevices.getUserMedia({\n    // TODO: support more recording configuration options\n    // https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints#properties_of_audio_tracks\n    // autoGainControl, echoCancellation, latency, noiseSuppression, volume\n    audio: {\n      deviceId,\n      channelCount,\n      sampleRate: SAMPLE_RATE,\n      echoCancellation: false,\n      // TODO: add advanced controls for these options\n      // @ts-ignore (should be in type)\n      autoGainControl: false,\n      noiseSuppression: false,\n    },\n    video: false,\n  });\n  const audioContext = getRecordingAudioContext();\n  const mediaStreamSourceNode = audioContext.createMediaStreamSource(stream);\n  const { recorderNode, stop } = await createPcmRecorderNode({\n    channelCount,\n    onData,\n    onFinish,\n  });\n  mediaStreamSourceNode.connect(recorderNode);\n  recorderNode.connect(audioContext.destination);\n  onStart();\n\n  const timeLimitSeconds = 10;\n  const maxSamples = timeLimitSeconds * audioContext.sampleRate;\n  let samplesRecorded = 0;\n  /**\n   * @type {Float32Array[][]}\n   */\n  const recordedChunks = Array(channelCount).fill([]);\n\n  /**\n   * @param {Float32Array[]} audioChannels\n   */\n  function onData(audioChannels) {\n    /**\n     * @type {number}\n     */\n    let sampleCount = 0;\n    for (let channel = 0; channel < channelCount; channel++) {\n      const chunk = audioChannels[channel];\n      const chunkSize = chunk.length;\n      const chunkSliced = chunk.slice(\n        0,\n        Math.min(chunkSize, maxSamples - samplesRecorded)\n      );\n      // check for out-of-bounds values and just clip them (ideally we shouldn't\n      // have out-of-bounds values but this sometimes happens. by clipping them\n      // we kind of force the user to deal with the input levels.)\n      for (let i = 0; i < chunkSliced.length; i++) {\n        if (chunkSliced[i] > 1) {\n          chunkSliced[i] = 1;\n        } else if (chunkSliced[i] < -1) {\n          chunkSliced[i] = -1;\n        }\n      }\n      if (!sampleCount) {\n        sampleCount = chunkSliced.length;\n      }\n      recordedChunks[channel].push(chunkSliced);\n    }\n    samplesRecorded += sampleCount;\n    // should never be >, but just in case we did something wrong we use >=\n    if (samplesRecorded >= maxSamples) {\n      onFinish();\n      stop();\n    }\n  }\n\n  /**\n   * @type {(wavBuffer: Uint8Array) => void}\n   */\n  let onDone;\n  /**\n   * @type {(error: unknown) => void}\n   */\n  let onError;\n  /**\n   * @type {Promise<Uint8Array>}\n   */\n  const mediaRecording = new Promise((resolve, reject) => {\n    onDone = resolve;\n    onError = reject;\n  });\n  let finished = false;\n\n  function onFinish() {\n    if (finished) {\n      return;\n    }\n\n    // create wav file\n    try {\n      const samples = recordedChunks.map((chunks) => {\n        const merged = new Float32Array(\n          chunks.reduce((len, chunk) => len + chunk.length, 0)\n        );\n        let offset = 0;\n        for (const chunk of chunks) {\n          merged.set(chunk, offset);\n          offset += chunk.length;\n        }\n        return merged;\n      });\n      const wav = new WaveFile();\n      wav.fromScratch(samples.length, audioContext.sampleRate, '32f', samples);\n      onDone(wav.toBuffer());\n    } catch (err) {\n      onError(err);\n    }\n\n    // clean up\n    const tracks = stream.getTracks();\n    for (const track of tracks) {\n      track.stop();\n    }\n    recorderNode.disconnect(audioContext.destination);\n    mediaStreamSourceNode.disconnect(recorderNode);\n    finished = true;\n  }\n\n  return {\n    stop,\n    mediaRecording,\n  };\n}\n","import React, { useCallback, useEffect, useState } from 'react';\n\nimport { captureAudio, getAudioInputDevices } from './utils/recording';\n\n/**\n * @typedef {{\n *   onRecordStart: () => void;\n *   onRecordFinish: (wavBuffer: Uint8Array) => void;\n *   onRecordError: (err: unknown) => void;\n * }} MediaRecordingCallbacks\n */\n\n/**\n * @param {MediaRecordingCallbacks} callbacks\n */\nfunction useMediaRecording({ onRecordStart, onRecordFinish, onRecordError }) {\n  const [captureDevices, setCaptureDevices] = useState(\n    /** @type {Map<string, import('./utils/recording').AudioDeviceInfoContainer> | null} */ (\n      null\n    )\n  );\n  const [selectedCaptureDeviceId, setSelectedCaptureDeviceId] = useState('');\n  useEffect(() => {\n    getAudioInputDevices().then((devices) => {\n      if (devices.length) {\n        setCaptureDevices(new Map(devices.map((d) => [d.device.deviceId, d])));\n        setSelectedCaptureDeviceId((id) => id || devices[0].device.deviceId);\n      }\n    });\n  }, []);\n  const [selectedChannelCount, setSelectedChannelCount] = useState(1);\n  useEffect(() => {\n    const selectedDeviceInfo =\n      captureDevices && captureDevices.get(selectedCaptureDeviceId);\n    if (selectedDeviceInfo) {\n      setSelectedChannelCount(selectedDeviceInfo.channelsAvailable);\n    }\n  }, [captureDevices, selectedCaptureDeviceId]);\n  const [recordingError, setRecordingError] = useState(\n    /** @type {Error | null} */ (null)\n  );\n  useEffect(() => {\n    if (recordingError) {\n      onRecordError(recordingError);\n    }\n  }, [recordingError, onRecordError]);\n  // to be set when recording is started\n  const [stop, setStop] = useState({ fn: () => {} });\n  const handleBeginRecording = useCallback(async () => {\n    const { mediaRecording, stop } = await captureAudio({\n      deviceId: selectedCaptureDeviceId,\n      channelCount: selectedChannelCount,\n      onStart: onRecordStart,\n    });\n    setStop({ fn: stop });\n    /**\n     * @type {Uint8Array}\n     */\n    let wavBuffer;\n    try {\n      wavBuffer = await mediaRecording;\n    } catch (err) {\n      setRecordingError(err);\n      return;\n    }\n    onRecordFinish(wavBuffer);\n  }, [\n    selectedCaptureDeviceId,\n    selectedChannelCount,\n    onRecordStart,\n    onRecordFinish,\n  ]);\n  return {\n    captureDevices,\n    selectedCaptureDeviceId,\n    selectedChannelCount,\n    recordingError,\n    setSelectedCaptureDeviceId,\n    setSelectedChannelCount,\n    beginRecording: handleBeginRecording,\n    stopRecording: stop.fn,\n  };\n}\n\n/**\n * @typedef {'ready' | 'capturing' | 'preparing' | 'error' | 'idle'} CaptureState\n */\n\n/**\n * @param {{ captureState: CaptureState } & MediaRecordingCallbacks} props\n */\nfunction SampleRecord({ captureState, ...callbacks }) {\n  const {\n    captureDevices,\n    selectedCaptureDeviceId,\n    selectedChannelCount,\n    recordingError,\n    setSelectedCaptureDeviceId,\n    setSelectedChannelCount,\n    beginRecording,\n    stopRecording,\n  } = useMediaRecording(callbacks);\n\n  if (captureState === 'idle') {\n    return null;\n  }\n\n  return (\n    <div style={{ paddingLeft: '2rem' }}>\n      {captureDevices ? (\n        <div>\n          <label>\n            Capture Device\n            <select\n              value={selectedCaptureDeviceId}\n              onChange={(e) => setSelectedCaptureDeviceId(e.target.value)}\n            >\n              {[...captureDevices].map(([id, { device }]) => (\n                <option key={id} value={id}>\n                  {device.label || id}\n                </option>\n              ))}\n            </select>\n          </label>\n          <label>\n            Channel count\n            <select\n              value={selectedChannelCount}\n              onChange={(e) => setSelectedChannelCount(Number(e.target.value))}\n            >\n              {[1, 2].map((count) => (\n                <option\n                  key={count}\n                  value={count}\n                  disabled={\n                    !captureDevices.has(selectedCaptureDeviceId) ||\n                    /** @type {import('./utils/recording').AudioDeviceInfoContainer} */ (\n                      captureDevices.get(selectedCaptureDeviceId)\n                    ).channelsAvailable < count\n                  }\n                >\n                  {count}\n                </option>\n              ))}\n            </select>\n          </label>\n        </div>\n      ) : (\n        'Loading capture devices...'\n      )}\n      <button\n        type=\"button\"\n        onClick={captureState === 'capturing' ? stopRecording : beginRecording}\n        disabled={captureState === 'preparing'}\n      >\n        {['capturing', 'preparing'].includes(captureState) ? 'Stop' : 'Record'}\n      </button>\n      <input\n        type=\"file\"\n        onChange={(e) => {\n          if (e.target.files) {\n            const file = e.target.files[0];\n            file.arrayBuffer().then((arrayBuffer) => {\n              callbacks.onRecordFinish(new Uint8Array(arrayBuffer));\n            });\n          }\n        }}\n      />\n    </div>\n  );\n}\n\nexport default SampleRecord;\n","import React, { useCallback, useEffect, useState } from 'react';\n\nimport SampleList from './SampleList';\nimport SampleDetail from './SampleDetail';\nimport SampleRecord from './SampleRecord';\nimport { factorySamples, SampleContainer, storeWavSourceFile } from './store';\n\n{\n  const css = `\n.volcaSampler {\n  padding: 2rem;\n  display: flex;\n  height: 100%;\n}\n\n.sampleListContainer {\n  width: 200px;\n  flex-shrink: 0;\n  padding-right: 0.5rem;\n  height: 100%;\n}\n\n.focusedSampleContainer {\n  flex-grow: 1;\n}\n\n.focusedSample {\n  padding-left: 2rem;\n}\n  `;\n  const style = document.createElement('style');\n  style.innerHTML = css;\n  document.body.appendChild(style);\n}\n/**\n * @type {Record<string, string>}\n */\nconst classes = [\n  'volcaSampler',\n  'sampleListContainer',\n  'sampleList',\n  'sampleListItem',\n  'focusedSampleContainer',\n  'focusedSample',\n].reduce((classes, className) => ({ ...classes, [className]: className }), {});\n\nfunction App() {\n  const [showingFactorySamples, setShowingFactorySamples] = useState(false);\n  const [samples, setSamples] = useState(\n    /** @type {Map<string, SampleContainer>} */ (new Map())\n  );\n  const [focusedSampleId, setFocusedSampleId] = useState(\n    /** @type {string | null} */ (null)\n  );\n  const [loadingSamples, setLoadingSamples] = useState(true);\n  const [captureState, setCaptureState] = useState(\n    /** @type {import('./SampleRecord').CaptureState} */ ('idle')\n  );\n  const selectedSampleBank = showingFactorySamples ? factorySamples : samples;\n  useEffect(() => {\n    // TODO: error handling\n    SampleContainer.getAllFromStorage()\n      .then((storedSamples) => {\n        setSamples(\n          (samples) =>\n            new Map([\n              ...samples,\n              ...storedSamples.map(\n                (sample) =>\n                  /** @type {[string, SampleContainer]} */ ([sample.id, sample])\n              ),\n            ])\n        );\n        // TODO: automatically set focused sample id to first.. easier with useReducer maybe\n      })\n      .finally(() => {\n        setLoadingSamples(false);\n      });\n  }, []);\n  useEffect(() => {\n    if (\n      selectedSampleBank.size &&\n      !(focusedSampleId && selectedSampleBank.has(focusedSampleId))\n    ) {\n      setFocusedSampleId([...selectedSampleBank.values()][0].id);\n    }\n  }, [selectedSampleBank, focusedSampleId]);\n\n  const handleRecordStart = useCallback(() => setCaptureState('capturing'), []);\n\n  /**\n   * @type {(wavBuffer: Uint8Array) => void}\n   * */\n  const handleRecordFinish = useCallback(async (wavBuffer) => {\n    setCaptureState('preparing');\n    const id = await storeWavSourceFile(wavBuffer);\n    const sample = new SampleContainer.Mutable({\n      name: 'New one',\n      sourceFileId: id,\n    });\n    await sample.persist();\n    setSamples((samples) => new Map([[sample.id, sample], ...samples]));\n    setShowingFactorySamples(false);\n    setFocusedSampleId(sample.id);\n    setCaptureState('idle');\n  }, []);\n\n  /**\n   * @type {(err: unknown) => void}\n   * */\n  const handleRecordError = useCallback((err) => {\n    console.error(err);\n    setCaptureState('error');\n  }, []);\n\n  return (\n    <div className={classes.volcaSampler}>\n      <select\n        value={JSON.stringify(showingFactorySamples)}\n        onChange={(e) => setShowingFactorySamples(JSON.parse(e.target.value))}\n      >\n        <option value=\"false\">Your Samples</option>\n        <option value=\"true\">Factory Samples</option>\n      </select>\n      <div className={classes.sampleListContainer}>\n        <SampleList\n          samples={selectedSampleBank}\n          selectedSampleId={captureState === 'idle' ? focusedSampleId : null}\n          readonly={['capturing', 'preparing'].includes(captureState)}\n          onNewSample={() => setCaptureState('ready')}\n          onSampleSelect={(id) => {\n            setFocusedSampleId(id);\n            setCaptureState('idle');\n          }}\n        />\n      </div>\n      <div className={classes.focusedSampleContainer}>\n        {captureState === 'idle' && (\n          <SampleDetail\n            sample={\n              (focusedSampleId && selectedSampleBank.get(focusedSampleId)) ||\n              null\n            }\n            onSampleUpdate={(id, update) => {\n              const sample = selectedSampleBank.get(id);\n              if (sample && sample instanceof SampleContainer.Mutable) {\n                setSamples((samples) =>\n                  new Map(samples).set(sample.id, sample.update(update))\n                );\n              }\n            }}\n            onSampleDuplicate={(id) => {\n              const sample = selectedSampleBank.get(id);\n              if (sample) {\n                const newSample = sample.duplicate();\n                setSamples(\n                  (samples) => new Map([[newSample.id, newSample], ...samples])\n                );\n                setShowingFactorySamples(false);\n              }\n            }}\n            onSampleDelete={(id) => {\n              const sample = selectedSampleBank.get(id);\n              if (sample && sample instanceof SampleContainer.Mutable) {\n                sample.remove();\n                setSamples((samples) => {\n                  const newSamples = new Map(samples);\n                  newSamples.delete(sample.id);\n                  return newSamples;\n                });\n              }\n            }}\n          />\n        )}\n        <SampleRecord\n          captureState={captureState}\n          onRecordStart={handleRecordStart}\n          onRecordFinish={handleRecordFinish}\n          onRecordError={handleRecordError}\n        />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}