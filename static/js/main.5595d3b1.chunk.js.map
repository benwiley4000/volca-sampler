{"version":3,"sources":["Header.js","utils/constants.js","store.js","utils/audioData.js","utils/waveform.js","WaveformDisplay.js","SampleList.js","WaveformEdit.js","utils/getSyroBindings.js","utils/syro.js","VolcaTransferControl.js","QualityBitDepthControl.js","NormalizeSwitch.js","SlotNumberInput.js","SampleDetail.js","WaveformReadonly.js","SampleDetailReadonly.js","utils/recording.js","SampleRecord.js","App.js","reportWebVitals.js","index.js","webpack:///./src/SlotNumberInput.module.scss?f412","webpack:///./src/Header.module.scss?0729","webpack:///./src/QualityBitDepthControl.module.scss?9765","webpack:///./src/SampleDetail.module.scss?90c6","webpack:///./src/SampleRecord.module.scss?a416","webpack:///./src/WaveformEdit.module.scss?5ac1","webpack:///./src/App.module.scss?cf1a","webpack:///./src/NormalizeSwitch.module.scss?71c6"],"names":[],"mappings":"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","file":"static/js/main.5595d3b1.chunk.js","sourcesContent":["import React from 'react';\nimport { Container } from 'react-bootstrap';\n\nimport classes from './Header.module.scss';\n\nconst Header = React.memo(\n  /**\n   * @param {{ onMenuOpen: () => void, onHeaderClick: () => void }} props\n   * @returns\n   */\n  function Header({ onMenuOpen, onHeaderClick }) {\n    return (\n      <div className={classes.titleBar}>\n        <span className={classes.menuIcon} onClick={onMenuOpen}>\n          â˜°\n        </span>\n        <Container fluid=\"sm\" className={classes.titleContainer}>\n          <h1 className={classes.title} onClick={onHeaderClick}>\n            <span className={classes.titleText} data-text=\"Volca Sample\">\n              Volca Sample\n              <span className={classes.titleR}>r</span>\n              <svg\n                viewBox=\"0 0 150 150\"\n                preserveAspectRatio=\"none\"\n                className={classes.titleStarburst}\n              >\n                {\n                  /** @type {void[]} */ (Array(24))\n                    .fill()\n                    .map((_, i, { length }) => (\n                      <polygon\n                        key={i}\n                        points=\"75,70 75,80 150,75\"\n                        transform-origin=\"75 75\"\n                        // @ts-ignore\n                        style={{ '--rotation': `${(i * 360) / length}deg` }}\n                      />\n                    ))\n                }\n              </svg>\n            </span>\n            <img\n              className={classes.titleGraphic}\n              src=\"volca_sample.png\"\n              alt=\"\"\n            />\n          </h1>\n        </Container>\n        <svg width={0} height={0}>\n          {/* https://tympanus.net/codrops/2019/01/22/svg-filter-effects-outline-text-with-femorphology/ */}\n          <filter id=\"outline\">\n            <feMorphology\n              in=\"SourceAlpha\"\n              result=\"DILATED\"\n              operator=\"dilate\"\n              radius=\"1\"\n            ></feMorphology>\n            <feFlood\n              floodColor=\"var(--stroke-color)\"\n              floodOpacity=\"1\"\n              result=\"PINK\"\n            ></feFlood>\n            <feComposite\n              in=\"PINK\"\n              in2=\"DILATED\"\n              operator=\"in\"\n              result=\"OUTLINE\"\n            ></feComposite>\n            <feMerge>\n              <feMergeNode in=\"OUTLINE\" />\n              <feMergeNode in=\"SourceGraphic\" />\n            </feMerge>\n          </filter>\n        </svg>\n      </div>\n    );\n  }\n);\n\nexport default Header;\n","export const SAMPLE_RATE = 31250;\n","import localforage from 'localforage';\nimport { v4 as uuidv4 } from 'uuid';\nimport { decode as decodeBase64 } from 'base64-arraybuffer';\n\nimport { SAMPLE_RATE } from './utils/constants.js';\nimport {\n  findSamplePeak,\n  getMonoSamplesFromAudioBuffer,\n  getSourceAudioBuffer,\n} from './utils/audioData.js';\nimport { getSamplePeaksForAudioBuffer } from './utils/waveform.js';\n\n/**\n * @typedef {{\n *   frames: [number, number];\n *   waveformPeaks: import('./utils/waveform').SamplePeaks;\n * }} TrimInfo\n */\n\n/**\n * @typedef {object} SampleContainerParams\n * @property {string} name\n * @property {string} sourceFileId\n * @property {TrimInfo} trim\n * @property {string} [id]\n * @property {{ type: string; ext: string } | null} [userFileInfo]\n * @property {number} [slotNumber]\n * @property {string} [dateSampled]\n * @property {string} [dateModified]\n * @property {boolean} [useCompression]\n * @property {number} [qualityBitDepth]\n * @property {boolean} [normalize]\n */\n\n/**\n * @typedef {object} SampleMetadata\n * @property {string} name\n * @property {string} sourceFileId\n * @property {TrimInfo} trim\n * @property {{ type: string; ext: string } | null} userFileInfo\n * @property {number} slotNumber\n * @property {string} dateSampled\n * @property {string} dateModified\n * @property {boolean} useCompression\n * @property {number} qualityBitDepth\n * @property {boolean} normalize\n * @property {string} metadataVersion\n */\n\n/**\n * @typedef {object} SampleMetadataUpdate\n * @property {string} [name]\n * @property {TrimInfo} [trim]\n * @property {number} [slotNumber]\n * @property {boolean} [useCompression]\n * @property {number} [qualityBitDepth]\n * @property {boolean} [normalize]\n */\n\n/**\n * @typedef {SampleMetadataUpdate | ((metadata: SampleMetadata) => SampleMetadataUpdate)} SampleMetadataUpdateArg\n */\n\nconst audioFileDataStore = localforage.createInstance({\n  name: 'audio_file_data',\n  driver: localforage.INDEXEDDB,\n});\n\nconst sampleMetadataStore = localforage.createInstance({\n  name: 'sample_metadata',\n  driver: localforage.INDEXEDDB,\n});\n\n/**\n * @param {Uint8Array} audioFileData\n * @returns {Promise<string>} id\n */\nexport async function storeAudioSourceFile(audioFileData) {\n  const id = uuidv4();\n  await audioFileDataStore.setItem(id, audioFileData);\n  return id;\n}\n\nconst METADATA_VERSION = '0.5.0';\n\n// These properties are considered fundamental and should never break\n/**\n * @typedef {{\n *   name: string;\n *   sourceFileId: string;\n *   id: string;\n *   metadataVersion: string;\n * }} OldMetadata\n */\n\n/**\n * @type {Record<string, (oldMetadata: OldMetadata) => OldMetadata | Promise<OldMetadata>>}\n */\nconst metadataUpgrades = {\n  '0.1.0': (oldMetadata) => {\n    /**\n     * @typedef {OldMetadata & { clip: [number, number] }} PrevMetadata\n     */\n    const { clip, ...prevMetadata } = /** @type {PrevMetadata} */ (oldMetadata);\n    const newMetadata = {\n      ...prevMetadata,\n      trimFrames: /** @type {[number, number]} */ (\n        clip.map((c) => Math.round(c * SAMPLE_RATE))\n      ),\n      metadataVersion: '0.2.0',\n    };\n    return newMetadata;\n  },\n  '0.2.0': async (oldMetadata) => {\n    /**\n     * @typedef {OldMetadata & { trimFrames: [number, number] }} PrevMetadata\n     */\n    const { trimFrames, ...prevMetadata } = /** @type {PrevMetadata} */ (\n      oldMetadata\n    );\n    const audioBuffer = await getSourceAudioBuffer(\n      prevMetadata.sourceFileId,\n      false\n    );\n    const waveformPeaks = await getSamplePeaksForAudioBuffer(\n      audioBuffer,\n      trimFrames\n    );\n    /**\n     * @type {TrimInfo}\n     */\n    const trim = {\n      frames: trimFrames,\n      waveformPeaks,\n    };\n    const newMetadata = {\n      ...prevMetadata,\n      trim,\n      metadataVersion: '0.3.0',\n    };\n    return newMetadata;\n  },\n  '0.3.0': (oldMetadata) => {\n    /**\n     * @typedef {OldMetadata & {\n     *   dateSampled: number;\n     *   dateModified: number;\n     * }} PrevMetadata\n     */\n    const { dateSampled, dateModified, ...prevMetadata } =\n      /** @type {PrevMetadata} */ (oldMetadata);\n    const newMetadata = {\n      ...prevMetadata,\n      dateSampled: new Date(dateSampled).toISOString(),\n      dateModified: new Date(dateModified).toISOString(),\n      metadataVersion: '0.4.0',\n    };\n    return newMetadata;\n  },\n  '0.4.0': async (oldMetadata) => {\n    /**\n     * @typedef {OldMetadata & {\n     *   scaleCoefficient: number;\n     *   trim: Omit<TrimInfo, 'waveformPeaks'> & {\n     *     waveformPeaks: Omit<\n     *       TrimInfo['waveformPeaks'],\n     *       'normalizationCoefficient'\n     *     >\n     *   }\n     * }} PrevMetadata\n     */\n    const {\n      scaleCoefficient,\n      trim: { frames: trimFrames, waveformPeaks },\n      ...prevMetadata\n    } = /** @type {PrevMetadata} */ (oldMetadata);\n    const audioBuffer = await getSourceAudioBuffer(\n      prevMetadata.sourceFileId,\n      false\n    );\n    const monoSamples = getMonoSamplesFromAudioBuffer(audioBuffer, trimFrames);\n    const samplePeak = findSamplePeak(monoSamples);\n    const newMetadata = {\n      ...prevMetadata,\n      normalize: scaleCoefficient !== 1,\n      trim: {\n        frames: trimFrames,\n        waveformPeaks: {\n          ...waveformPeaks,\n          normalizationCoefficient: 1 / samplePeak,\n        },\n      },\n      metadataVersion: '0.5.0',\n    };\n    return newMetadata;\n  },\n};\n\n/**\n * @param {OldMetadata} oldMetadata\n * @returns {Promise<SampleMetadata>}\n */\nasync function upgradeMetadata(oldMetadata) {\n  let prevMetadata = oldMetadata;\n  while (prevMetadata.metadataVersion !== METADATA_VERSION) {\n    /**\n     * @type {(typeof metadataUpgrades)[string] | undefined}\n     */\n    const matchedUpgrade = metadataUpgrades[prevMetadata.metadataVersion];\n    if (!matchedUpgrade) {\n      console.warn(\n        `Failed to properly upgrade metadata for sample \"${prevMetadata.name}\"`\n      );\n      prevMetadata = {\n        name: prevMetadata.name,\n        sourceFileId: prevMetadata.sourceFileId,\n        id: prevMetadata.id,\n        metadataVersion: METADATA_VERSION,\n      };\n      break;\n    }\n    prevMetadata = await matchedUpgrade(prevMetadata);\n  }\n  return /** @type {SampleMetadata} */ (/** @type {unknown} */ (prevMetadata));\n}\n\nexport class SampleContainer {\n  /**\n   * @param {SampleContainerParams} sampleContainerParams\n   */\n  constructor({\n    name,\n    sourceFileId,\n    trim,\n    id = uuidv4(),\n    userFileInfo = null,\n    slotNumber = 0,\n    dateSampled = new Date().toISOString(),\n    dateModified = dateSampled,\n    useCompression = true,\n    qualityBitDepth = 16,\n    normalize = true,\n  }) {\n    /** @readonly */\n    this.id = id;\n    /**\n     * @readonly\n     * @type {SampleMetadata}\n     */\n    this.metadata = {\n      name,\n      sourceFileId,\n      trim,\n      userFileInfo,\n      slotNumber,\n      dateSampled,\n      dateModified,\n      useCompression,\n      qualityBitDepth,\n      normalize,\n      metadataVersion: METADATA_VERSION,\n    };\n  }\n\n  /**\n   * @returns {SampleContainer}\n   */\n  duplicate() {\n    const copy = new SampleContainer.Mutable({\n      ...this.metadata,\n      name: `${this.metadata.name} (copy)`,\n      dateModified: new Date().toISOString(),\n    });\n    // async - does not block\n    copy.persist();\n    return copy;\n  }\n\n  static Mutable = class extends SampleContainer {\n    /**\n     * @param {SampleContainerParams} sampleContainerParams\n     */\n    constructor(sampleContainerParams) {\n      super(sampleContainerParams);\n      setTimeout(async () => {\n        const ids = await sampleMetadataStore.keys();\n        if (!ids.includes(this.id)) {\n          console.warn(\n            `Expected sample metadata container ${this.id} to be persisted`\n          );\n        }\n      });\n    }\n\n    async persist() {\n      await sampleMetadataStore.setItem(this.id, this.metadata);\n    }\n\n    /**\n     * @param {SampleMetadataUpdateArg} updater\n     * @returns {SampleContainer}\n     */\n    update(updater) {\n      const { id, metadata } = this;\n      const update =\n        typeof updater === 'function' ? updater(metadata) : updater;\n      // if the update doesn't change anything, return the existing container\n      if (\n        /** @type {(keyof SampleMetadataUpdate)[]} */ (\n          Object.keys(update)\n        ).every((key) => update[key] === metadata[key])\n      ) {\n        return this;\n      }\n      /**\n       * @type {SampleMetadata}\n       */\n      const newMetadata = {\n        ...metadata,\n        ...update,\n        dateModified: new Date().toISOString(),\n      };\n      const newContainer = new SampleContainer.Mutable({ id, ...newMetadata });\n      // async - does not block\n      newContainer.persist();\n      return newContainer;\n    }\n\n    async remove() {\n      await sampleMetadataStore.removeItem(this.id);\n      // if the source file is on the server, don't worry about cleanup\n      if (this.metadata.sourceFileId.includes('.')) {\n        return;\n      }\n      // check if source file is used by other sample containers\n      const allMetadata = await SampleContainer.getAllMetadataFromStore();\n      for (const [, { sourceFileId }] of allMetadata) {\n        if (sourceFileId === this.metadata.sourceFileId) {\n          // still used.. don't do anything\n          return;\n        }\n      }\n      // clean up dangling source file from storage\n      await audioFileDataStore.removeItem(this.metadata.sourceFileId);\n    }\n  };\n\n  /**\n   * @private\n   * @type {Map<string, Uint8Array>}\n   */\n  static sourceFileData = new Map();\n\n  /**\n   * @private\n   * @type {string[]}\n   */\n  static recentlyCachedSourceFileIds = [];\n\n  /** @readonly @private */\n  static MAX_CACHED = 10;\n\n  /**\n   * @param {string} sourceFileId\n   * @param {Uint8Array} data\n   */\n  static cacheSourceFileData(sourceFileId, data) {\n    this.sourceFileData.set(sourceFileId, data);\n    this.recentlyCachedSourceFileIds = [\n      sourceFileId,\n      ...this.recentlyCachedSourceFileIds.filter((id) => id !== sourceFileId),\n    ];\n    const stale = this.recentlyCachedSourceFileIds.slice(this.MAX_CACHED);\n    for (const sourceFileId of stale) {\n      this.sourceFileData.delete(sourceFileId);\n    }\n    this.recentlyCachedSourceFileIds = this.recentlyCachedSourceFileIds.slice(\n      0,\n      this.MAX_CACHED\n    );\n  }\n\n  /**\n   * @param {string} sourceFileId\n   * @returns {Promise<Uint8Array>}\n   */\n  static async getSourceFileData(sourceFileId) {\n    {\n      const data = this.sourceFileData.get(sourceFileId);\n      if (data) {\n        return data;\n      }\n    }\n    if (sourceFileId.includes('.')) {\n      const res = await fetch(sourceFileId);\n      if (res.status >= 400) {\n        return Promise.reject(\n          new Error(`Failed to fetch source file \"${sourceFileId}\"`)\n        );\n      }\n      // assume it's a URL pointing to a an audio file\n      const buffer = await res.arrayBuffer();\n      const data = new Uint8Array(buffer);\n      this.cacheSourceFileData(sourceFileId, data);\n      return data;\n    }\n    /**\n     * @type {unknown}\n     */\n    const data = await audioFileDataStore.getItem(sourceFileId);\n    if (data) {\n      if (data instanceof Uint8Array) {\n        this.cacheSourceFileData(sourceFileId, data);\n        return data;\n      }\n      return Promise.reject('Source data is of unexpected type');\n    }\n    return Promise.reject('Missing source data');\n  }\n\n  /**\n   * @protected\n   */\n  static async getAllMetadataFromStore() {\n    /**\n     * @type {Map<string, SampleMetadata>}\n     */\n    const sampleMetadata = new Map();\n    /**\n     * @type {Promise<void>[]}\n     */\n    const upgradePromises = [];\n    await sampleMetadataStore.iterate((metadata, id) => {\n      if (metadata) {\n        upgradePromises.push(\n          upgradeMetadata(metadata)\n            .then((upgradedMetadata) => {\n              sampleMetadata.set(id, upgradedMetadata);\n            })\n            .catch((err) => {\n              console.error(err);\n              console.warn(\n                `Failed to upgrade metadata \"${id}\" (${metadata.name}); ignoring.`\n              );\n            })\n        );\n      }\n    });\n    await Promise.all(upgradePromises);\n    return sampleMetadata;\n  }\n\n  static async getAllFromStorage() {\n    const sampleMetadata = await this.getAllMetadataFromStore();\n    const factorySampleParams = await getFactorySampleParams();\n    const sourceIds = (await audioFileDataStore.keys()).concat(\n      factorySampleParams.map(({ sourceFileId }) => sourceFileId)\n    );\n    const sampleContainers = /** @type {SampleContainer[]} */ (\n      [...sampleMetadata]\n        .map(([id, metadata]) => {\n          const { sourceFileId } = metadata;\n          if (!sourceIds.includes(sourceFileId)) {\n            console.warn(\n              `Found metadata \"${\n                metadata.name || id\n              }\" with missing data \"${sourceFileId}; ignoring.`\n            );\n            return null;\n          }\n          return new SampleContainer.Mutable({ id, ...metadata });\n        })\n        .filter(Boolean)\n    ).sort(\n      ({ metadata: { dateModified: a } }, { metadata: { dateModified: b } }) =>\n        a > b ? -1 : b > a ? 1 : 0\n    );\n    return sampleContainers;\n  }\n}\n\n/**\n * @type {Promise<import('../public/factory-samples.json')> | undefined}\n */\nlet factorySampleParamsPromise;\nfunction getFactorySampleParams() {\n  if (!factorySampleParamsPromise) {\n    factorySampleParamsPromise = fetch('factory-samples.json').then((res) =>\n      res.json()\n    );\n  }\n  return factorySampleParamsPromise;\n}\n\nexport async function getFactorySamples() {\n  const factorySampleParams = await getFactorySampleParams();\n  return new Map(\n    factorySampleParams.map((params) => [\n      params.id,\n      new SampleContainer({\n        ...params,\n        normalize: false,\n        trim: {\n          frames: [params.trim.frames[0], params.trim.frames[1]],\n          waveformPeaks: {\n            ...params.trim.waveformPeaks,\n            positive: new Float32Array(\n              decodeBase64(params.trim.waveformPeaks.positive)\n            ),\n            negative: new Float32Array(\n              decodeBase64(params.trim.waveformPeaks.negative)\n            ),\n          },\n        },\n      }),\n    ])\n  );\n}\n","import {\n  createContext,\n  createElement,\n  useCallback,\n  useContext,\n  useMemo,\n  useRef,\n} from 'react';\nimport getWavFileHeaders from 'wav-headers';\n\nimport { SampleContainer } from '../store.js';\nimport { SAMPLE_RATE } from './constants.js';\n\n/**\n * @param {Float32Array} array\n * @param {[number, number]} trimFrames\n */\nexport function getTrimmedView(array, trimFrames) {\n  const frameSizeInBytes = 4;\n  const byteOffset = trimFrames[0] * frameSizeInBytes;\n  const viewLength = array.length - trimFrames[0] - trimFrames[1];\n  return new Float32Array(array.buffer, byteOffset, viewLength);\n}\n\n/**\n * @param {AudioBuffer} audioBuffer\n * @param {[number, number]} trimFrames\n */\nexport function getMonoSamplesFromAudioBuffer(audioBuffer, trimFrames) {\n  const trimmedLength = audioBuffer.length - trimFrames[0] - trimFrames[1];\n  const samples = new Float32Array(trimmedLength);\n  const channels = /** @type {void[]} */ (Array(audioBuffer.numberOfChannels))\n    .fill()\n    .map((_, i) => getTrimmedView(audioBuffer.getChannelData(i), trimFrames));\n  for (let i = 0; i < trimmedLength; i++) {\n    let monoSample = 0;\n    for (let j = 0; j < channels.length; j++) {\n      monoSample += channels[j][i];\n    }\n    monoSample /= channels.length;\n    samples[i] = monoSample;\n  }\n  return samples;\n}\n\n/**\n * Finds most significant magnitude in array of samples.\n * @param {Float32Array} samples array of floats between -1 and 1\n * @returns {number} peak value between 0 and 1\n */\nexport function findSamplePeak(samples) {\n  let peak = 0;\n  for (const sample of samples) {\n    const abs = Math.abs(sample);\n    if (abs > peak) {\n      peak = abs;\n    }\n  }\n  return peak;\n}\n\n/**\n * Scales an array of samples according to a specified coefficient.\n * Note: mutates input array (no return value).\n * @param {Float32Array} samples array of floats\n * @param {number} coef float value to multiply against each sample\n */\nfunction scaleSamples(samples, coef) {\n  if (coef !== 1) {\n    for (let i = 0; i < samples.length; i++) {\n      samples[i] *= coef;\n    }\n  }\n}\n\n/**\n * Normalizes an array of samples so the peak value is 1 or -1.\n * Note: mutates input array (no return value).\n * @param {Float32Array} samples array of floats\n */\nfunction normalizeSamples(samples) {\n  const peak = findSamplePeak(samples);\n  scaleSamples(samples, 1 / peak);\n}\n\n/**\n * Reduces precision of samples by converting them to integers of a given bit\n * depth then back to floats. Note: mutates input array (no return value).\n * @param {Float32Array} samples array of floats between -1 and 1\n * @param {number} qualityBitDepth number from 8 to 16\n */\nfunction applyQualityBitDepthToSamples(samples, qualityBitDepth) {\n  const signedMax = 2 ** (qualityBitDepth - 1);\n  for (let i = 0; i < samples.length; i++) {\n    samples[i] = Math.round(samples[i] * signedMax) / signedMax;\n  }\n}\n\n/**\n * Check for values greater than 1 or less than -1 and just clamp them (ideally\n * we shouldn't have out-of-bounds samples but this sometimes happens.. by\n * clamping them we kind of force the user to deal with the input levels).\n * Note: mutates input array (no return value).\n * @param {Float32Array} samples array of floats\n */\nexport function clampOutOfBoundsValues(samples) {\n  for (let i = 0; i < samples.length; i++) {\n    if (samples[i] > 1) {\n      samples[i] = 1;\n    } else if (samples[i] < -1) {\n      samples[i] = -1;\n    }\n  }\n}\n\n/**\n * @param {Float32Array[]} sampleChannels\n * @returns {Float32Array}\n */\nexport function interleaveSampleChannels(sampleChannels) {\n  const channelCount = sampleChannels.length;\n  const sampleCount = sampleChannels[0].length;\n  const interleaved = new Float32Array(channelCount * sampleCount);\n  for (let sampleIndex = 0; sampleIndex < interleaved.length; sampleIndex++) {\n    const i = channelCount * sampleIndex;\n    for (let ch = 0; ch < channelCount; ch++) {\n      interleaved[i + ch] = sampleChannels[ch][sampleIndex];\n    }\n  }\n  return interleaved;\n}\n\n/**\n * @param {Float32Array} samples\n */\nexport function convertSamplesTo16Bit(samples) {\n  const samples16 = new Int16Array(samples.length);\n  const signedMax = 2 ** 15;\n  for (let i = 0; i < samples.length; i++) {\n    samples16[i] = samples[i] === 1 ? signedMax - 1 : signedMax * samples[i];\n  }\n  return samples16;\n}\n\nexport function getAudioContextConstructor() {\n  /**\n   * @typedef {typeof window.AudioContext} AudioContextConstructor\n   */\n  const AudioContext =\n    window.AudioContext ||\n    /**\n     * @type {typeof window & {\n     *   webkitAudioContext: AudioContextConstructor;\n     * }}\n     */ (window).webkitAudioContext;\n  return AudioContext;\n}\n\n/**\n * @type {AudioContext | undefined}\n */\nlet targetAudioContext;\n\nfunction getTargetAudioContext() {\n  const AudioContext = getAudioContextConstructor();\n  return (targetAudioContext =\n    targetAudioContext || new AudioContext({ sampleRate: SAMPLE_RATE }));\n}\n\n/**\n * @param {Uint8Array} audioFileBuffer audio file to transform into audio buffer\n * @returns {Promise<AudioBuffer>}\n */\nexport async function getAudioBufferForAudioFileData(audioFileBuffer) {\n  // make a copy of the data (since decodeAudioData will empty the source array)\n  const bufferCopy = new Uint8Array(audioFileBuffer);\n  /**\n   * @type {AudioBuffer}\n   */\n  const audioBuffer = await new Promise((resolve, reject) => {\n    getTargetAudioContext().decodeAudioData(bufferCopy.buffer, resolve, reject);\n  });\n  return audioBuffer;\n}\n\n/**\n * @param {string} sourceFileId sourceFileId to grab from store\n * @param {boolean} shouldClampValues do we need to clamp out of bounds values\n * @returns {Promise<AudioBuffer>}\n */\nexport async function getSourceAudioBuffer(sourceFileId, shouldClampValues) {\n  const sourceFileData = await SampleContainer.getSourceFileData(sourceFileId);\n  const audioBuffer = await getAudioBufferForAudioFileData(sourceFileData);\n  if (shouldClampValues) {\n    for (let channel = 0; channel < audioBuffer.numberOfChannels; channel++) {\n      clampOutOfBoundsValues(audioBuffer.getChannelData(channel));\n    }\n  }\n  return audioBuffer;\n}\n\n/**\n * Given sample container, returns a 16-bit mono wav file with the sample's\n * metadata parameters applied\n * @param {import('../store').SampleContainer} sampleContainer\n * @returns {Promise<{ data: Uint8Array; sampleRate: number }>}\n */\nexport async function getTargetWavForSample(sampleContainer) {\n  const {\n    qualityBitDepth,\n    sourceFileId,\n    userFileInfo,\n    normalize,\n    trim: { frames: trimFrames },\n  } = sampleContainer.metadata;\n  if (\n    qualityBitDepth < 8 ||\n    qualityBitDepth > 16 ||\n    !Number.isInteger(qualityBitDepth)\n  ) {\n    throw new Error(\n      `Expected bit depth between 8 and 16. Received: ${qualityBitDepth}`\n    );\n  }\n  const sourceAudioBuffer = await getSourceAudioBuffer(\n    sourceFileId,\n    Boolean(userFileInfo)\n  );\n  const samples =\n    sourceAudioBuffer.numberOfChannels === 1\n      ? getTrimmedView(sourceAudioBuffer.getChannelData(0), trimFrames)\n      : getMonoSamplesFromAudioBuffer(sourceAudioBuffer, trimFrames);\n  if (normalize) {\n    normalizeSamples(samples);\n  }\n  if (qualityBitDepth < 16) {\n    applyQualityBitDepthToSamples(samples, qualityBitDepth);\n  }\n  const samples16 = convertSamplesTo16Bit(samples);\n  const samplesByteLength = samples16.length * 2;\n  /**\n   * @type {Uint8Array}\n   */\n  const wavHeader = getWavFileHeaders({\n    channels: 1,\n    sampleRate: sourceAudioBuffer.sampleRate,\n    bitDepth: 16,\n    dataLength: samplesByteLength,\n  });\n  const wavBuffer = new Uint8Array(wavHeader.length + samplesByteLength);\n  wavBuffer.set(wavHeader);\n  wavBuffer.set(new Uint8Array(samples16.buffer), wavHeader.length);\n  return {\n    data: wavBuffer,\n    sampleRate: 16,\n  };\n}\n\nconst audioPlaybackContextDefaultValue = {\n  /**\n   * @param {AudioBuffer} audioBuffer buffer to play\n   * @param {{\n   *   onTimeUpdate?: (currentTime: number) => void;\n   *   onEnded?: () => void;\n   * }} [opts]\n   * @returns {() => void} stop\n   */\n  playAudioBuffer(audioBuffer, opts) {\n    throw new Error('Must render AudioPlaybackContextProvider');\n  },\n};\n\nconst AudioPlaybackContext = createContext(audioPlaybackContextDefaultValue);\n\n/**\n * @param {React.PropsWithChildren<{}>} props\n * @returns\n */\nexport function AudioPlaybackContextProvider({ children }) {\n  const stopCurrent = useRef(() => {});\n\n  const playAudioBuffer = useCallback(\n    /**\n     * @type {(typeof audioPlaybackContextDefaultValue.playAudioBuffer)}\n     */\n    (audioBuffer, { onTimeUpdate = () => null, onEnded = () => null } = {}) => {\n      stopCurrent.current();\n      const audioContext = getTargetAudioContext();\n      const source = audioContext.createBufferSource();\n      source.buffer = audioBuffer;\n      source.connect(audioContext.destination);\n      source.start();\n      const startTime = audioContext.currentTime;\n      onTimeUpdate(0);\n      let frame = requestAnimationFrame(updateCurrentTime);\n      function updateCurrentTime() {\n        onTimeUpdate(audioContext.currentTime - startTime);\n        frame = requestAnimationFrame(updateCurrentTime);\n      }\n      let stopped = false;\n      source.addEventListener('ended', () => {\n        if (!stopped) {\n          onTimeUpdate(audioBuffer.duration);\n          onEnded();\n        }\n        cancelAnimationFrame(frame);\n      });\n      function stop() {\n        if (!stopped) {\n          source.stop();\n          cancelAnimationFrame(frame);\n          onEnded();\n          stopped = true;\n        }\n      }\n      stopCurrent.current = stop;\n      return stop;\n    },\n    []\n  );\n\n  const contextValue = useMemo(\n    () => ({\n      playAudioBuffer,\n    }),\n    [playAudioBuffer]\n  );\n\n  return createElement(\n    AudioPlaybackContext.Provider,\n    { value: contextValue },\n    children\n  );\n}\n\nexport function useAudioPlaybackContext() {\n  return useContext(AudioPlaybackContext);\n}\n","import { useEffect, useMemo, useRef, useState } from 'react';\n\nimport {\n  getMonoSamplesFromAudioBuffer,\n  getSourceAudioBuffer,\n  findSamplePeak,\n} from './audioData.js';\n\nexport const GROUP_PIXEL_WIDTH = 6;\n\nexport const WAVEFORM_CACHED_WIDTH = GROUP_PIXEL_WIDTH * 44; // 264\n\n/**\n * @typedef {{\n *   positive: Float32Array;\n *   negative: Float32Array;\n *   normalizationCoefficient: number\n * }} SamplePeaks\n */\n\n/**\n * @param {Float32Array} samples an array of floats from -1 to 1\n * @param {number} containerPixelWidth the size of the waveform container\n * @returns {SamplePeaks} arrays of peak positive and negative values\n */\nexport function getPeaksForSamples(samples, containerPixelWidth) {\n  // the number of samples represented for each peak\n  const groupSize = Math.floor(\n    (GROUP_PIXEL_WIDTH * samples.length) / containerPixelWidth\n  );\n  // Cut off whatever's left after dividing into blocks of length [groupSize]\n  const positive = new Float32Array(Math.floor(samples.length / groupSize));\n  const negative = new Float32Array(Math.floor(samples.length / groupSize));\n  for (let i = 0; i < positive.length; i++) {\n    const group = new Float32Array(\n      samples.buffer,\n      i * groupSize * 4,\n      groupSize\n    );\n    let max = 0;\n    let min = 0;\n    for (const sample of group) {\n      if (sample > max) {\n        max = sample;\n      }\n      if (sample < min) {\n        min = sample;\n      }\n    }\n    // clamp in case there are out-of-bounds values\n    positive[i] = Math.min(1, max);\n    negative[i] = Math.max(-1, min);\n  }\n  const ignoredSamplesCount = samples.length % groupSize;\n  const peakSearchArray = new Float32Array(\n    positive.length + negative.length + ignoredSamplesCount\n  );\n  peakSearchArray.set(positive, 0);\n  peakSearchArray.set(negative, positive.length);\n  peakSearchArray.set(\n    new Float32Array(\n      samples.buffer,\n      (samples.length - ignoredSamplesCount) * 4,\n      ignoredSamplesCount\n    ),\n    positive.length + negative.length\n  );\n  const samplePeak = findSamplePeak(peakSearchArray);\n  return {\n    positive,\n    negative,\n    normalizationCoefficient: 1 / samplePeak,\n  };\n}\n\n/**\n * @param {AudioBuffer} audioBuffer\n * @param {[number, number]} trimFrames\n */\nexport async function getSamplePeaksForAudioBuffer(audioBuffer, trimFrames) {\n  const monoSamples = getMonoSamplesFromAudioBuffer(audioBuffer, trimFrames);\n  const waveformPeaks = getPeaksForSamples(monoSamples, WAVEFORM_CACHED_WIDTH);\n  return waveformPeaks;\n}\n\n/**\n * @param {import('../store').SampleContainer} sample\n * @returns {{\n *   sample: import('../store').SampleContainer;\n *   sourceAudioBuffer: AudioBuffer | null;\n * }}\n */\nexport function useLoadedSample(sample) {\n  const [loadedAudioBuffer, setSourceAudioBuffer] = useState(\n    /** @type {[string, AudioBuffer] | null} */ (null)\n  );\n  useEffect(() => {\n    let cancelled = false;\n    (async () => {\n      if (cancelled) return;\n      const audioBuffer = await getSourceAudioBuffer(\n        sample.metadata.sourceFileId,\n        Boolean(sample.metadata.userFileInfo)\n      );\n      if (cancelled) return;\n      setSourceAudioBuffer([sample.metadata.sourceFileId, audioBuffer]);\n    })();\n    return () => {\n      cancelled = true;\n    };\n  }, [sample.metadata.sourceFileId, sample.metadata.userFileInfo]);\n\n  // We need to hold onto an internal state because when the sample changes,\n  // the sourceAudioBuffer loads asynchronously and we want to avoid trying\n  // to apply the new sample's metadata to the old sample's audio.\n  const displayedSample = useRef(sample);\n  if (\n    loadedAudioBuffer &&\n    sample.metadata.sourceFileId === loadedAudioBuffer[0]\n  ) {\n    displayedSample.current = sample;\n  }\n\n  return {\n    sample: displayedSample.current,\n    sourceAudioBuffer: loadedAudioBuffer && loadedAudioBuffer[1],\n  };\n}\n\n/**\n * @param {AudioBuffer | null} sourceAudioBuffer\n */\nexport function useWaveformInfo(sourceAudioBuffer) {\n  const monoSamples = useMemo(\n    () =>\n      sourceAudioBuffer\n        ? getMonoSamplesFromAudioBuffer(sourceAudioBuffer, [0, 0])\n        : new Float32Array(),\n    [sourceAudioBuffer]\n  );\n  const [waveformElement, waveformRef] = useState(\n    /** @type {HTMLElement | null} */ (null)\n  );\n  const [size, setSize] = useState({ width: 0, height: 0 });\n  const pixelWidth = useMemo(\n    // size will initially be 0 so use waveform element width if size isn't set\n    () => waveformElement && (size.width || waveformElement.offsetWidth),\n    [waveformElement, size]\n  );\n  const peaks = useMemo(() => {\n    if (!pixelWidth || !monoSamples.length) {\n      return {\n        positive: new Float32Array(),\n        negative: new Float32Array(),\n        normalizationCoefficient: Infinity,\n      };\n    }\n    return getPeaksForSamples(monoSamples, pixelWidth);\n  }, [pixelWidth, monoSamples]);\n  return {\n    monoSamples,\n    waveformRef,\n    pixelWidth,\n    peaks,\n    onResize: setSize,\n  };\n}\n","import React, {\n  useImperativeHandle,\n  useLayoutEffect,\n  useRef,\n  useState,\n} from 'react';\nimport { styled } from 'tonami';\nimport ResizeObserver from 'resize-observer-polyfill';\n\nimport { GROUP_PIXEL_WIDTH } from './utils/waveform.js';\n\nconst WaveformCanvas = styled.canvas({\n  width: '100%',\n  height: '100%',\n  display: 'block',\n  imageRendering: 'pixelated',\n});\n\n/**\n * @param {HTMLCanvasElement} canvas\n * @param {(size: {width: number; height: number}) => void} onResize\n */\nfunction observeCanvas(canvas, onResize) {\n  /**\n   * @param {number} width\n   * @param {number} height\n   */\n  function setCanvasSize(width, height) {\n    canvas.width = width;\n    canvas.height = height;\n  }\n  setCanvasSize(canvas.offsetWidth, canvas.offsetHeight);\n  onResize({ width: canvas.offsetWidth, height: canvas.offsetHeight });\n  const observer = new ResizeObserver(([entry]) => {\n    const { width, height } = entry.contentRect;\n    setCanvasSize(width, height);\n    onResize({ width, height });\n  });\n  observer.observe(canvas);\n  return () => observer.disconnect();\n}\n\n/**\n * @param {HTMLCanvasElement} canvas\n * @param {import('./utils/waveform.js').SamplePeaks} peaks\n * @param {number} scaleCoefficient\n */\nfunction drawWaveform(canvas, peaks, scaleCoefficient) {\n  const documentStyle = getComputedStyle(document.documentElement);\n  const colorRed = documentStyle.getPropertyValue('--bs-primary');\n  const colorDarkRed = documentStyle.getPropertyValue('--bs-primary-darkened');\n  const ctx = /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));\n  ctx.imageSmoothingEnabled = false;\n  const { width, height } = canvas;\n  ctx.clearRect(0, 0, width, height);\n  const positiveHeight = Math.floor(height * (2 / 3)) + 1;\n  ctx.fillStyle = colorRed;\n  peaks.positive.forEach((peak, i) => {\n    const basePeakHeight = positiveHeight * peak; // float\n    // make the positive bar always at least 1px tall to avoid empty sections\n    const scaledPeakHeight = Math.max(\n      Math.round(scaleCoefficient * basePeakHeight),\n      1\n    );\n    ctx.fillRect(\n      i * GROUP_PIXEL_WIDTH,\n      positiveHeight - scaledPeakHeight,\n      GROUP_PIXEL_WIDTH - 1,\n      scaledPeakHeight\n    );\n  });\n  const negativeHeight = height - positiveHeight;\n  ctx.fillStyle = colorDarkRed;\n  peaks.negative.forEach((peak, i) => {\n    const basePeakHeight = negativeHeight * peak * -1; // float\n    const scaledPeakHeight = Math.round(scaleCoefficient * basePeakHeight);\n    ctx.fillRect(\n      i * GROUP_PIXEL_WIDTH,\n      positiveHeight,\n      GROUP_PIXEL_WIDTH - 1,\n      scaledPeakHeight\n    );\n  });\n}\n\n/**\n * @typedef {{\n *   peaks: import('./utils/waveform').SamplePeaks;\n *   scaleCoefficient?: number;\n *   waveformRef?: React.Ref<HTMLElement | null>;\n *   onResize?: (size: { width: number; height: number }) => void;\n * }} WaveformProps\n */\n\n/**\n * @param {WaveformProps} props\n */\nfunction WaveformDisplayCanvas({\n  peaks,\n  scaleCoefficient,\n  waveformRef,\n  onResize,\n}) {\n  /**\n   * @type {React.RefObject<HTMLCanvasElement>}\n   */\n  const canvasRef = useRef(null);\n  useImperativeHandle(waveformRef, () => canvasRef.current);\n  const [lastResize, setLastResize] = useState(Symbol());\n  const sizeRef = useRef({ width: 0, height: 0 });\n  useLayoutEffect(() => {\n    if (!canvasRef.current) {\n      throw new Error('Canvas should be defined');\n    }\n    // set sizeRef before setting up observer to avoid triggering\n    // the initial render multiple times\n    sizeRef.current.width = canvasRef.current.offsetWidth;\n    sizeRef.current.height = canvasRef.current.offsetHeight;\n    if (onResize) {\n      onResize({ ...sizeRef.current });\n    }\n    return observeCanvas(canvasRef.current, ({ width, height }) => {\n      if (\n        width !== sizeRef.current.width ||\n        height !== sizeRef.current.height\n      ) {\n        setLastResize(Symbol());\n        sizeRef.current.width = width;\n        sizeRef.current.height = height;\n        if (onResize) {\n          onResize({ ...sizeRef.current });\n        }\n      }\n    });\n  }, [onResize]);\n  useLayoutEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) {\n      throw new Error('Canvas should be defined');\n    }\n    // wait for animation frame..\n    let frame = requestAnimationFrame(() => {\n      // just before animation frame..\n      frame = requestAnimationFrame(() => {\n        // after animation frame..\n        // for some reason the draw doesn't reliably show up before this\n        drawWaveform(\n          canvas,\n          peaks,\n          scaleCoefficient === undefined\n            ? peaks.normalizationCoefficient\n            : scaleCoefficient\n        );\n      });\n    });\n    return () => cancelAnimationFrame(frame);\n  }, [peaks, scaleCoefficient, lastResize]);\n  return <WaveformCanvas ref={canvasRef} />;\n}\n\nexport default WaveformDisplayCanvas;\n","import React, { useLayoutEffect, useRef, useState } from 'react';\nimport { styled } from 'tonami';\nimport { WAVEFORM_CACHED_WIDTH } from './utils/waveform';\nimport WaveformDisplay from './WaveformDisplay';\n\nconst WaveformContainer = styled.div({\n  width: `${WAVEFORM_CACHED_WIDTH}px`,\n  height: '40px',\n});\n\nconst intersectionObserverAvailable =\n  typeof IntersectionObserver !== 'undefined';\n\nconst SampleListItem = React.memo(\n  /**\n   * @param {{\n   *   sample: import('./store').SampleContainer;\n   *   selected: boolean;\n   *   onSampleSelect: (id: string) => void;\n   * }} props\n   */\n  function SampleListItem({ sample, selected, onSampleSelect }) {\n    /**\n     * @type {React.RefObject<HTMLDivElement>}\n     */\n    const waveformContainerRef = useRef(null);\n    const [waveformSeen, setWaveformSeen] = useState(\n      !intersectionObserverAvailable\n    );\n    useLayoutEffect(() => {\n      if (!intersectionObserverAvailable) {\n        return;\n      }\n      const waveformContainer = waveformContainerRef.current;\n      if (!waveformContainer) {\n        throw new Error('Waveform container should be defined');\n      }\n      // check if waveform is visible now.. if so, render immediately\n      const rect = waveformContainer.getBoundingClientRect();\n      if (\n        rect.top + rect.height >= 0 &&\n        rect.bottom - rect.height <= window.innerHeight\n      ) {\n        setWaveformSeen(true);\n        return;\n      }\n      // otherwise set up an observer for when the waveform does become visible\n      const observer = new IntersectionObserver(([entry]) => {\n        if (entry.isIntersecting) {\n          setWaveformSeen(true);\n          observer.unobserve(waveformContainer);\n        }\n      });\n      observer.observe(waveformContainer);\n      return () => observer.disconnect();\n    }, []);\n    return (\n      <li\n        className={['list-group-item', selected ? 'active' : ''].join(' ')}\n        onClick={() => onSampleSelect(sample.id)}\n      >\n        <div>{sample.metadata.name}</div>\n        <WaveformContainer ref={waveformContainerRef}>\n          {waveformSeen && (\n            <WaveformDisplay peaks={sample.metadata.trim.waveformPeaks} />\n          )}\n        </WaveformContainer>\n      </li>\n    );\n  }\n);\n\n/**\n * @param {{\n *   samples: Map<string, import('./store').SampleContainer>;\n *   selectedSampleId: string | null;\n *   onSampleSelect: (id: string) => void;\n * }} props\n */\nfunction SampleList({ samples, selectedSampleId, onSampleSelect }) {\n  const elementsMap = useRef(\n    /** @type {WeakMap<import('./store').SampleContainer, React.ReactElement>} */ (\n      new WeakMap()\n    )\n  );\n  /** @type {React.ReactElement[]} */\n  const elementsList = [];\n  for (const sample of samples.values()) {\n    let element = elementsMap.current.get(sample);\n    if (!element) {\n      element = (\n        <SampleListItem\n          key={sample.id}\n          sample={sample}\n          selected={sample.id === selectedSampleId}\n          onSampleSelect={onSampleSelect}\n        />\n      );\n      elementsMap.current.set(sample, element);\n    }\n    elementsList.push(element);\n  }\n  return <ul className=\"list-group list-group-flush\">{elementsList}</ul>;\n}\n\nexport default SampleList;\n","import React, {\n  useCallback,\n  useEffect,\n  useLayoutEffect,\n  useMemo,\n  useRef,\n  useState,\n} from 'react';\nimport { Button, OverlayTrigger, Tooltip } from 'react-bootstrap';\nimport playIcon from '@material-design-icons/svg/filled/play_arrow.svg';\nimport stopIcon from '@material-design-icons/svg/filled/stop.svg';\n\nimport {\n  findSamplePeak,\n  getTrimmedView,\n  useAudioPlaybackContext,\n} from './utils/audioData.js';\nimport { useLoadedSample, useWaveformInfo } from './utils/waveform.js';\nimport WaveformDisplay from './WaveformDisplay.js';\n\nimport classes from './WaveformEdit.module.scss';\n\n/**\n * @param {number} sec\n * @param {number} decimals\n */\nfunction formatTime(sec, decimals) {\n  return `0:${sec.toFixed(decimals).padStart(3 + decimals, '0')}`;\n}\n\nconst WaveformEdit = React.memo(\n  /**\n   * @param {{\n   *   sample: import('./store').SampleContainer;\n   *   previewWav: AudioBuffer | null;\n   *   onSetTrimFrames: (updateTrimFrames: (old: [number, number]) => [number, number]) => void;\n   * }} props\n   */\n  function WaveformEdit({ sample: _sample, previewWav, onSetTrimFrames }) {\n    const {\n      sample: {\n        metadata: {\n          trim: { frames: trimFrames },\n          normalize,\n        },\n      },\n      sourceAudioBuffer,\n    } = useLoadedSample(_sample);\n\n    const { monoSamples, waveformRef, pixelWidth, peaks, onResize } =\n      useWaveformInfo(sourceAudioBuffer);\n\n    const trimmedSamplePeak = useMemo(() => {\n      if (!sourceAudioBuffer) {\n        return 0;\n      }\n      const trimmedView = getTrimmedView(monoSamples, trimFrames);\n      const samplePeak = findSamplePeak(trimmedView);\n      return samplePeak;\n    }, [sourceAudioBuffer, monoSamples, trimFrames]);\n\n    const normalizationCoefficient = 1 / trimmedSamplePeak;\n\n    const [trimFramesLocal, setTrimFramesLocal] = useState({\n      trimFrames,\n      cursor: /** @type {number | null} */ (null),\n    });\n    useEffect(() => {\n      setTrimFramesLocal({ trimFrames, cursor: null });\n    }, [trimFrames]);\n\n    const trimPixels = useMemo(() => {\n      if (!monoSamples.length || !pixelWidth) {\n        return [0, 0];\n      }\n      const factor = pixelWidth / monoSamples.length;\n      return trimFramesLocal.trimFrames.map((frames) => frames * factor);\n    }, [pixelWidth, monoSamples.length, trimFramesLocal.trimFrames]);\n\n    /** @type {React.RefObject<HTMLDivElement>} */\n    const leftTrimHandleRef = useRef(null);\n    /** @type {React.RefObject<HTMLDivElement>} */\n    const rightTrimHandleRef = useRef(null);\n\n    /** @type {React.RefObject<HTMLDivElement>} */\n    const waveformOverlayRef = useRef(null);\n\n    {\n      const leftTrimLastX = useRef(/** @type {number | null} */ (null));\n      const rightTrimLastX = useRef(/** @type {number | null} */ (null));\n\n      const waveformOverlayDownFrame = useRef(\n        /** @type {number | null} */ (null)\n      );\n      const waveformOverlayDragged = useRef(false);\n\n      const trimFramesUpdateTimeout = useRef(\n        /** @type {NodeJS.Timeout | null} */ (null)\n      );\n\n      useLayoutEffect(() => {\n        if (trimFramesUpdateTimeout.current) {\n          clearTimeout(trimFramesUpdateTimeout.current);\n          trimFramesUpdateTimeout.current = null;\n        }\n      }, [trimFramesLocal]);\n\n      const moveCallbackParams = useMemo(() => {\n        if (!pixelWidth || !monoSamples.length) {\n          return null;\n        }\n        const minPixelWidth = 10;\n        const minFrameWidth = Math.max(\n          // enforce at least 2000 sample selection\n          2000,\n          Math.ceil((minPixelWidth * monoSamples.length) / pixelWidth)\n        );\n        return {\n          pixelWidth,\n          monoSamplesLength: monoSamples.length,\n          minFrameWidth,\n        };\n      }, [pixelWidth, monoSamples.length]);\n\n      const trimFramesLocalRef = useRef(trimFramesLocal);\n      trimFramesLocalRef.current = trimFramesLocal;\n      useEffect(() => {\n        if (\n          !moveCallbackParams ||\n          !leftTrimHandleRef.current ||\n          !rightTrimHandleRef.current ||\n          !waveformOverlayRef.current\n        ) {\n          return;\n        }\n\n        const leftHandle = leftTrimHandleRef.current;\n        const rightHandle = rightTrimHandleRef.current;\n        const waveformOverlay = waveformOverlayRef.current;\n\n        const { pixelWidth, monoSamplesLength, minFrameWidth } =\n          moveCallbackParams;\n        let waveformClientLeft = 0;\n        // we'll update this as needed (on mousedown/touchstart). this is\n        // partially because on resize, the page layout is still shifting and\n        // reading the value early can be unreliable.\n        function updateWaveformClientLeft() {\n          waveformClientLeft = waveformOverlay.getBoundingClientRect().left;\n        }\n\n        /** @param {MouseEvent | TouchEvent} e */\n        function onLeftHandleDown(e) {\n          if (e instanceof TouchEvent) {\n            e.preventDefault();\n          }\n          document.body.style.userSelect = 'none';\n          const { pageX } = e instanceof MouseEvent ? e : e.touches[0];\n          leftTrimLastX.current = pageX;\n        }\n\n        /** @param {MouseEvent | TouchEvent} e */\n        function onRightHandleDown(e) {\n          if (e instanceof TouchEvent) {\n            e.preventDefault();\n          }\n          document.body.style.userSelect = 'none';\n          const { pageX } = e instanceof MouseEvent ? e : e.touches[0];\n          rightTrimLastX.current = pageX;\n        }\n\n        /** @param {MouseEvent | TouchEvent} e */\n        function onWaveformOverlayDown(e) {\n          if (e instanceof TouchEvent) {\n            e.preventDefault();\n          }\n          if (e.detail === 2) {\n            // double-mousedown... select everything\n            onSetTrimFrames(() => [0, 0]);\n            return;\n          }\n          document.body.style.userSelect = 'none';\n          const { clientX } = e instanceof MouseEvent ? e : e.touches[0];\n          updateWaveformClientLeft();\n          const waveformX = Math.max(\n            0,\n            Math.min(pixelWidth, clientX - waveformClientLeft)\n          );\n          const ratio = waveformX / pixelWidth;\n          const frameFrom = Math.round(monoSamplesLength * ratio);\n          const frameToTentative = frameFrom + minFrameWidth;\n          const frameTo =\n            frameToTentative < monoSamplesLength\n              ? frameToTentative\n              : frameFrom - minFrameWidth;\n          if (frameTo < 0) {\n            // looks like we don't have enough room to make the minimum selection\n            return;\n          }\n          setTrimFramesLocal({\n            trimFrames: [\n              Math.min(frameFrom, frameTo),\n              monoSamplesLength - 1 - Math.max(frameFrom, frameTo),\n            ],\n            cursor: waveformX - 1,\n          });\n          waveformOverlayDownFrame.current = frameFrom;\n        }\n\n        /** @param {number} diff */\n        function moveLeftHandle(diff) {\n          const ratio = diff / pixelWidth;\n          const frameDiff = Math.round(monoSamplesLength * ratio);\n          setTrimFramesLocal(({ trimFrames }) => {\n            let newValue = trimFrames[0] + frameDiff;\n            newValue = Math.min(\n              newValue,\n              monoSamplesLength - trimFrames[1] - minFrameWidth\n            );\n            newValue = Math.max(newValue, 0);\n            return {\n              trimFrames: [newValue, trimFrames[1]],\n              cursor: null,\n            };\n          });\n        }\n\n        /** @param {MouseEvent | TouchEvent} e */\n        function onLeftHandleMove(e) {\n          if (leftTrimLastX.current === null) {\n            return;\n          }\n          if (e instanceof TouchEvent) {\n            e.preventDefault();\n          }\n          const { pageX } = e instanceof MouseEvent ? e : e.touches[0];\n          const diff = pageX - leftTrimLastX.current;\n          if (diff) {\n            moveLeftHandle(diff);\n            leftTrimLastX.current = pageX;\n          }\n        }\n\n        /** @param {number} diff */\n        function moveRightHandle(diff) {\n          const ratio = diff / pixelWidth;\n          const frameDiff = Math.round(monoSamplesLength * ratio);\n          setTrimFramesLocal(({ trimFrames }) => {\n            let newValue = trimFrames[1] + frameDiff;\n            newValue = Math.min(\n              newValue,\n              monoSamplesLength - trimFrames[0] - minFrameWidth\n            );\n            newValue = Math.max(newValue, 0);\n            return {\n              trimFrames: [trimFrames[0], newValue],\n              cursor: null,\n            };\n          });\n        }\n\n        /** @param {MouseEvent | TouchEvent} e */\n        function onRightHandleMove(e) {\n          if (rightTrimLastX.current === null) {\n            return;\n          }\n          if (e instanceof TouchEvent) {\n            e.preventDefault();\n          }\n          const { pageX } = e instanceof MouseEvent ? e : e.touches[0];\n          const diff = rightTrimLastX.current - pageX;\n          if (diff) {\n            moveRightHandle(diff);\n            rightTrimLastX.current = pageX;\n          }\n        }\n\n        let adjustedViaKeyboard = false;\n\n        /** @param {KeyboardEvent} e */\n        function onLeftHandleKeyDown(e) {\n          if (leftTrimLastX.current !== null) {\n            return;\n          }\n          let handled = true;\n          switch (e.key) {\n            case 'ArrowLeft':\n              moveLeftHandle(-1);\n              break;\n            case 'ArrowRight':\n              moveLeftHandle(1);\n              break;\n            default:\n              handled = false;\n              break;\n          }\n          if (handled) {\n            e.stopPropagation();\n            e.preventDefault();\n            adjustedViaKeyboard = true;\n          }\n        }\n\n        /** @param {KeyboardEvent} e */\n        function onRightHandleKeyDown(e) {\n          if (rightTrimLastX.current !== null) {\n            return;\n          }\n          let handled = true;\n          switch (e.key) {\n            case 'ArrowLeft':\n              moveRightHandle(1);\n              break;\n            case 'ArrowRight':\n              moveRightHandle(-1);\n              break;\n            default:\n              handled = false;\n              break;\n          }\n          if (handled) {\n            e.stopPropagation();\n            e.preventDefault();\n            adjustedViaKeyboard = true;\n          }\n        }\n\n        /** @param {MouseEvent | TouchEvent} e */\n        function onWaveformOverlayMove(e) {\n          if (waveformOverlayDownFrame.current === null) {\n            return;\n          }\n          if (e instanceof TouchEvent) {\n            e.preventDefault();\n          }\n          const frameFrom = waveformOverlayDownFrame.current;\n          const { clientX } = e instanceof MouseEvent ? e : e.touches[0];\n          const waveformX = Math.max(\n            0,\n            Math.min(pixelWidth, clientX - waveformClientLeft)\n          );\n          const ratio = waveformX / pixelWidth;\n          const frameToTentative = Math.max(\n            0,\n            Math.min(\n              monoSamplesLength - 1,\n              Math.round(monoSamplesLength * ratio)\n            )\n          );\n          if (frameToTentative !== waveformOverlayDownFrame.current) {\n            waveformOverlayDragged.current = true;\n            const aboveFrameMin = frameFrom + minFrameWidth;\n            const belowFrameMax = frameFrom - minFrameWidth;\n            const frameTo =\n              frameToTentative > frameFrom\n                ? aboveFrameMin < monoSamplesLength\n                  ? Math.max(frameToTentative, aboveFrameMin)\n                  : belowFrameMax\n                : belowFrameMax >= 0\n                ? Math.min(frameToTentative, belowFrameMax)\n                : aboveFrameMin;\n            setTrimFramesLocal({\n              trimFrames: [\n                Math.min(frameFrom, frameTo),\n                monoSamplesLength - 1 - Math.max(frameFrom, frameTo),\n              ],\n              cursor: frameFrom < frameTo ? waveformX : waveformX - 1,\n            });\n          }\n        }\n\n        /** @param {MouseEvent} e */\n        function onMouseMove(e) {\n          onLeftHandleMove(e);\n          onRightHandleMove(e);\n          onWaveformOverlayMove(e);\n        }\n\n        /** @param {MouseEvent | TouchEvent | KeyboardEvent} e */\n        function onUp(e) {\n          if (\n            leftTrimLastX.current !== null ||\n            rightTrimLastX.current !== null ||\n            waveformOverlayDownFrame.current !== null ||\n            adjustedViaKeyboard\n          ) {\n            if (e instanceof TouchEvent || e instanceof KeyboardEvent) {\n              e.preventDefault();\n            }\n            if (\n              waveformOverlayDownFrame.current &&\n              !waveformOverlayDragged.current &&\n              e.detail === 1\n            ) {\n              // we might be doing a double click so let's delay the trim frames\n              // update by 250ms. this avoids annoying/unnecessary visual updates.\n              // note: a dblclick might take longer (up to 500ms normally) but I\n              // think most users will do it in in under 250ms.\n              trimFramesUpdateTimeout.current = setTimeout(() => {\n                trimFramesUpdateTimeout.current = null;\n                onSetTrimFrames(() => trimFramesLocalRef.current.trimFrames);\n              }, 250);\n            } else {\n              onSetTrimFrames(() => trimFramesLocalRef.current.trimFrames);\n            }\n            leftTrimLastX.current = null;\n            rightTrimLastX.current = null;\n            waveformOverlayDownFrame.current = null;\n            waveformOverlayDragged.current = false;\n            adjustedViaKeyboard = false;\n          }\n          document.body.style.userSelect = 'unset';\n        }\n\n        /** @param {MouseEvent | TouchEvent | KeyboardEvent} e */\n        function onActionOutsideWaveformOverlay(e) {\n          if (e.target instanceof Node && waveformOverlay.contains(e.target)) {\n            return;\n          }\n          if (trimFramesUpdateTimeout.current) {\n            clearTimeout(trimFramesUpdateTimeout.current);\n            trimFramesUpdateTimeout.current = null;\n            onSetTrimFrames(() => trimFramesLocalRef.current.trimFrames);\n          }\n        }\n\n        leftHandle.addEventListener('touchstart', onLeftHandleDown);\n        leftHandle.addEventListener('mousedown', onLeftHandleDown);\n        rightHandle.addEventListener('touchstart', onRightHandleDown);\n        rightHandle.addEventListener('mousedown', onRightHandleDown);\n        waveformOverlay.addEventListener('touchstart', onWaveformOverlayDown);\n        waveformOverlay.addEventListener('mousedown', onWaveformOverlayDown);\n        leftHandle.addEventListener('touchmove', onLeftHandleMove);\n        rightHandle.addEventListener('touchmove', onRightHandleMove);\n        leftHandle.addEventListener('keydown', onLeftHandleKeyDown);\n        rightHandle.addEventListener('keydown', onRightHandleKeyDown);\n        waveformOverlay.addEventListener('touchmove', onWaveformOverlayMove);\n        window.addEventListener('mousemove', onMouseMove);\n        leftHandle.addEventListener('touchend', onUp);\n        leftHandle.addEventListener('touchcancel', onUp);\n        leftHandle.addEventListener('keyup', onUp);\n        rightHandle.addEventListener('touchend', onUp);\n        rightHandle.addEventListener('keyup', onUp);\n        rightHandle.addEventListener('touchcancel', onUp);\n        waveformOverlay.addEventListener('touchend', onUp);\n        waveformOverlay.addEventListener('touchcancel', onUp);\n        window.addEventListener('mouseup', onUp);\n        window.addEventListener('touchstart', onActionOutsideWaveformOverlay, {\n          capture: true,\n        });\n        window.addEventListener('mousedown', onActionOutsideWaveformOverlay, {\n          capture: true,\n        });\n        window.addEventListener('keydown', onActionOutsideWaveformOverlay, {\n          capture: true,\n        });\n        return () => {\n          leftHandle.removeEventListener('touchstart', onLeftHandleDown);\n          leftHandle.removeEventListener('mousedown', onLeftHandleDown);\n          rightHandle.removeEventListener('touchstart', onRightHandleDown);\n          rightHandle.removeEventListener('mousedown', onRightHandleDown);\n          waveformOverlay.removeEventListener(\n            'touchstart',\n            onWaveformOverlayDown\n          );\n          waveformOverlay.removeEventListener(\n            'mousedown',\n            onWaveformOverlayDown\n          );\n          leftHandle.removeEventListener('touchmove', onLeftHandleMove);\n          rightHandle.removeEventListener('touchmove', onRightHandleMove);\n          leftHandle.removeEventListener('keydown', onLeftHandleKeyDown);\n          rightHandle.removeEventListener('keydown', onRightHandleKeyDown);\n          waveformOverlay.removeEventListener(\n            'touchmove',\n            onWaveformOverlayMove\n          );\n          window.removeEventListener('mousemove', onMouseMove);\n          leftHandle.removeEventListener('touchend', onUp);\n          leftHandle.removeEventListener('touchcancel', onUp);\n          leftHandle.removeEventListener('keyup', onUp);\n          rightHandle.removeEventListener('touchend', onUp);\n          rightHandle.removeEventListener('keyup', onUp);\n          rightHandle.removeEventListener('touchcancel', onUp);\n          waveformOverlay.removeEventListener('touchend', onUp);\n          waveformOverlay.removeEventListener('touchcancel', onUp);\n          window.removeEventListener('mouseup', onUp);\n          window.removeEventListener(\n            'touchstart',\n            onActionOutsideWaveformOverlay,\n            { capture: true }\n          );\n          window.removeEventListener(\n            'mousedown',\n            onActionOutsideWaveformOverlay,\n            { capture: true }\n          );\n          window.removeEventListener(\n            'keydown',\n            onActionOutsideWaveformOverlay,\n            {\n              capture: true,\n            }\n          );\n        };\n      }, [moveCallbackParams, onSetTrimFrames]);\n    }\n\n    const { playAudioBuffer } = useAudioPlaybackContext();\n\n    // to be set when playback is started\n    const stopPreviewPlayback = useRef(() => {});\n    useEffect(() => {\n      return () => stopPreviewPlayback.current();\n    }, [_sample, trimFramesLocal]);\n\n    const [callbackOnPreviewWav, setCallbackOnPreviewWav] = useState(\n      /** @type {{ fn: () => void } | null} */ (null)\n    );\n    useEffect(() => {\n      if (previewWav instanceof AudioBuffer && callbackOnPreviewWav) {\n        setCallbackOnPreviewWav(null);\n        callbackOnPreviewWav.fn();\n      }\n    }, [previewWav, callbackOnPreviewWav]);\n\n    const [playbackProgress, setPlaybackProgress] = useState(0);\n    const [isPlaybackActive, setIsPlaybackActive] = useState(false);\n\n    const [displayedTime, setDisplayedTime] = useState('');\n    useEffect(() => {\n      if (previewWav) {\n        setDisplayedTime(\n          isPlaybackActive\n            ? formatTime(playbackProgress * previewWav.duration, 1)\n            : formatTime(previewWav.duration, 1)\n        );\n      }\n    }, [previewWav, isPlaybackActive, playbackProgress]);\n\n    const handlePlay = useCallback(\n      /** @param {MouseEvent | KeyboardEvent} e */\n      (e) => {\n        if (isPlaybackActive) {\n          stopPreviewPlayback.current();\n        } else if (previewWav) {\n          stopPreviewPlayback.current = playAudioBuffer(previewWav, {\n            onTimeUpdate(currentTime) {\n              setPlaybackProgress(currentTime / previewWav.duration);\n            },\n            onEnded() {\n              setIsPlaybackActive(false);\n            },\n          });\n          setPlaybackProgress(0);\n          setIsPlaybackActive(true);\n        } else {\n          const target = /** @type {EventTarget} */ (e.target);\n          // wait until the audio buffer is ready then simulate an event\n          // to retry this handler. it's important that we simulate\n          // another action because otherwise iOS won't let us play the\n          // audio later.\n          setCallbackOnPreviewWav({\n            fn: () => target.dispatchEvent(e),\n          });\n        }\n      },\n      [isPlaybackActive, playAudioBuffer, previewWav]\n    );\n\n    useEffect(() => {\n      /** @param {KeyboardEvent} e */\n      function handleSpace(e) {\n        if (e.key === ' ') {\n          e.preventDefault();\n          handlePlay(e);\n        }\n      }\n      document.addEventListener('keydown', handleSpace);\n      return () => document.removeEventListener('keydown', handleSpace);\n    }, [handlePlay]);\n\n    return (\n      <div\n        className={[\n          classes.waveformContainer,\n          isPlaybackActive ? classes.playbackActive : '',\n        ].join(' ')}\n        style={{\n          // @ts-ignore\n          '--cursor-display':\n            trimFramesLocal.cursor === null ? 'none' : 'unset',\n          // @ts-ignore\n          '--cursor-left': `${trimFramesLocal.cursor}px`,\n          // @ts-ignore\n          '--trim-pixels-left': `${trimPixels[0]}px`,\n          // @ts-ignore\n          '--trim-pixels-right': `${trimPixels[1]}px`,\n          // @ts-ignore\n          '--playback-progress': `${100 * playbackProgress}%`,\n        }}\n      >\n        <WaveformDisplay\n          waveformRef={waveformRef}\n          peaks={peaks}\n          scaleCoefficient={normalize ? normalizationCoefficient : 1}\n          onResize={onResize}\n        />\n        <div className={classes.playbackOverlay}>\n          <div className={classes.playback} />\n        </div>\n        <div className={classes.playbackButtonContainer}>\n          <OverlayTrigger\n            delay={{ show: 400, hide: 0 }}\n            overlay={\n              <Tooltip>\n                Preview how your sample will sound on the Volca Sample\n              </Tooltip>\n            }\n          >\n            <Button variant=\"dark\" onClick={(e) => handlePlay(e.nativeEvent)}>\n              <img\n                src={isPlaybackActive ? stopIcon : playIcon}\n                alt=\"Play preview\"\n              />\n            </Button>\n          </OverlayTrigger>\n          {displayedTime && <span>{displayedTime}</span>}\n        </div>\n        <div className={classes.cursor} />\n        <div className={[classes.trim, classes.left].join(' ')}>\n          <div className={classes.bar} />\n          <div\n            ref={leftTrimHandleRef}\n            className={classes.handle}\n            tabIndex={0}\n          />\n          {sourceAudioBuffer && Boolean(monoSamples.length) && (\n            <span className={classes.time}>\n              {formatTime(\n                (sourceAudioBuffer.duration * trimFramesLocal.trimFrames[0]) /\n                  monoSamples.length,\n                2\n              )}\n            </span>\n          )}\n        </div>\n        <div className={[classes.trim, classes.right].join(' ')}>\n          <div className={classes.bar} />\n          <div\n            ref={rightTrimHandleRef}\n            className={classes.handle}\n            tabIndex={0}\n          />\n          {sourceAudioBuffer && Boolean(monoSamples.length) && (\n            <span className={classes.time}>\n              {formatTime(\n                (sourceAudioBuffer.duration *\n                  (monoSamples.length - 1 - trimFramesLocal.trimFrames[1])) /\n                  monoSamples.length,\n                2\n              )}\n            </span>\n          )}\n        </div>\n        <div ref={waveformOverlayRef} className={classes.waveformOverlay} />\n      </div>\n    );\n  }\n);\n\nexport default WaveformEdit;\n","/**\n * @typedef {{\n *   prepareSampleBufferFromWavData(\n *     wavData: Uint8Array,\n *     bytes: number,\n *     slotNumber: number,\n *     quality: number,\n *     useCompression: 0 | 1,\n *     onUpdate: number\n *   ): number;\n *   prepareSampleBufferFrom16BitPcmData(\n *     wavData: Uint8Array,\n *     bytes: number,\n *     rate: number,\n *     slotNumber: number,\n *     quality: number,\n *     useCompression: 0 | 1,\n *     onUpdate: number\n *   ): number;\n *   getSampleBufferChunkPointer(sampleBufferUpdate: number): number;\n *   getSampleBufferChunkSize(sampleBufferUpdate: number): number;\n *   getSampleBufferProgress(sampleBufferUpdate: number): number;\n *   getSampleBufferTotalSize(sampleBufferUpdate: number): number;\n *   cancelSampleBufferWork(workHandle: number): void;\n *   registerUpdateCallback(\n *     cb: (sampleBufferContainer: number) => void\n *   ): number;\n *   unregisterUpdateCallback(pointer: number): void;\n *   heap8Buffer(): ArrayBuffer;\n * }} SyroBindings\n */\n\n/**\n * @type {Promise<SyroBindings> | undefined}\n */\nlet syroBindingsPromise;\n\nexport async function getSyroBindings() {\n  if (typeof window.CREATE_SYRO_BINDINGS !== 'function') {\n    return Promise.reject(\n      'Expected CREATE_SYRO_BINDINGS global function to exist'\n    );\n  }\n  return (syroBindingsPromise =\n    syroBindingsPromise ||\n    window.CREATE_SYRO_BINDINGS().then(async (Module) => {\n      /**\n       * @type {SyroBindings}\n       */\n      return {\n        prepareSampleBufferFromWavData: Module.cwrap(\n          'prepareSampleBufferFromWavData',\n          'number',\n          ['array', 'number', 'number', 'number', 'number']\n        ),\n        // TODO: put this back when C function works correctly\n        // prepareSampleBufferFrom16BitPcmData: Module.cwrap(\n        //   'prepareSampleBufferFrom16BitPcmData',\n        //   'number',\n        //   ['array', 'number', 'number', 'number', 'number', 'number']\n        // ),\n        prepareSampleBufferFrom16BitPcmData() {\n          throw new Error(\n            'This function does not work. Use prepareSampleBufferFromWavData.'\n          );\n        },\n        getSampleBufferChunkPointer: Module.cwrap(\n          'getSampleBufferChunkPointer',\n          'number',\n          ['number']\n        ),\n        getSampleBufferChunkSize: Module.cwrap(\n          'getSampleBufferChunkSize',\n          'number',\n          ['number']\n        ),\n        getSampleBufferProgress: Module.cwrap(\n          'getSampleBufferProgress',\n          'number',\n          ['number']\n        ),\n        getSampleBufferTotalSize: Module.cwrap(\n          'getSampleBufferTotalSize',\n          'number',\n          ['number']\n        ),\n        cancelSampleBufferWork: Module.cwrap('cancelSampleBufferWork', null, [\n          'number',\n        ]),\n        registerUpdateCallback(cb) {\n          return Module.addFunction(cb, 'vi');\n        },\n        unregisterUpdateCallback(pointer) {\n          Module.removeFunction(pointer);\n        },\n        heap8Buffer() {\n          return Module.HEAP8.buffer;\n        },\n      };\n    }));\n}\n","import { getSyroBindings } from './getSyroBindings.js';\nimport { getTargetWavForSample } from './audioData.js';\n\n/**\n * @param {import('../store').SampleContainer} sampleContainer\n * @param {(progress: number) => void} onProgress\n * @returns {{\n *   sampleBufferPromise: Promise<Uint8Array>;\n *   cancelWork: () => void;\n * }}\n */\nexport function getSampleBuffer(sampleContainer, onProgress) {\n  let cancelled = false;\n  let onCancel = () => {};\n  return {\n    cancelWork() {\n      cancelled = true;\n      onCancel();\n    },\n    sampleBufferPromise: (async () => {\n      const {\n        prepareSampleBufferFromWavData,\n        getSampleBufferChunkPointer,\n        getSampleBufferChunkSize,\n        getSampleBufferProgress,\n        getSampleBufferTotalSize,\n        cancelSampleBufferWork,\n        registerUpdateCallback,\n        unregisterUpdateCallback,\n        heap8Buffer,\n      } = await getSyroBindings();\n      if (cancelled) {\n        return new Uint8Array();\n      }\n      const { data } = await getTargetWavForSample(sampleContainer);\n      if (cancelled) {\n        return new Uint8Array();\n      }\n      /**\n       * @type {Uint8Array | undefined}\n       */\n      let sampleBuffer;\n      let progress = 0;\n      const onUpdate = registerUpdateCallback((sampleBufferUpdatePointer) => {\n        if (cancelled) {\n          return;\n        }\n        const totalSize = getSampleBufferTotalSize(sampleBufferUpdatePointer);\n        if (!sampleBuffer) {\n          sampleBuffer = new Uint8Array(totalSize);\n        }\n        const chunkPointer = getSampleBufferChunkPointer(\n          sampleBufferUpdatePointer\n        );\n        const chunkSize = getSampleBufferChunkSize(sampleBufferUpdatePointer);\n        const bytesProgress = getSampleBufferProgress(\n          sampleBufferUpdatePointer\n        );\n        // save a new copy of the data so it doesn't disappear\n        sampleBuffer.set(\n          new Uint8Array(heap8Buffer(), chunkPointer, chunkSize),\n          bytesProgress - chunkSize\n        );\n        progress = bytesProgress / totalSize;\n      });\n      const workHandle = prepareSampleBufferFromWavData(\n        data,\n        data.length,\n        sampleContainer.metadata.slotNumber,\n        sampleContainer.metadata.qualityBitDepth,\n        sampleContainer.metadata.useCompression ? 1 : 0,\n        onUpdate\n      );\n      onProgress(progress);\n      try {\n        await /** @type {Promise<void>} */ (\n          new Promise((resolve) => {\n            /**\n             * @type {number}\n             */\n            let frame;\n            onCancel = () => {\n              cancelAnimationFrame(frame);\n              cancelSampleBufferWork(workHandle);\n              resolve();\n            };\n            checkProgress();\n            function checkProgress() {\n              // TODO: find a way to detect if the web worker failed to load, in\n              // which case we should reject the promise\n              if (progress) {\n                onProgress(progress);\n                if (progress >= 1) {\n                  resolve();\n                  return;\n                }\n              }\n              frame = requestAnimationFrame(checkProgress);\n            }\n          })\n        );\n      } finally {\n        onCancel = () => {};\n        unregisterUpdateCallback(onUpdate);\n      }\n      if (cancelled) {\n        return new Uint8Array();\n      }\n      if (!sampleBuffer) {\n        throw new Error('Unexpected condition: sampleBuffer should be defined');\n      }\n      return sampleBuffer;\n    })(),\n  };\n}\n","import React, { useCallback, useEffect, useRef, useState } from 'react';\nimport { Button, ProgressBar } from 'react-bootstrap';\n\nimport {\n  getAudioBufferForAudioFileData,\n  useAudioPlaybackContext,\n} from './utils/audioData.js';\nimport { getSampleBuffer } from './utils/syro.js';\n\n/**\n * @param {{\n *   sample: import('./store').SampleContainer;\n * }} props\n */\nfunction VolcaTransferControl({ sample }) {\n  const [syroProgress, setSyroProgress] = useState(0);\n  const [syroTransferState, setSyroTransferState] = useState(\n    /** @type {'idle' | 'transferring' | 'error'} */ ('idle')\n  );\n  const [syroAudioBuffer, setSyroAudioBuffer] = useState(\n    /** @type {AudioBuffer | Error | null} */ (null)\n  );\n  const [callbackOnSyroBuffer, setCallbackOnSyroBuffer] = useState(\n    /** @type {{ fn: () => void } | null} */ (null)\n  );\n  useEffect(() => {\n    if (syroAudioBuffer instanceof AudioBuffer && callbackOnSyroBuffer) {\n      setCallbackOnSyroBuffer(null);\n      callbackOnSyroBuffer.fn();\n    }\n  }, [syroAudioBuffer, callbackOnSyroBuffer]);\n  // to be set when transfer or playback is started\n  const stop = useRef(() => {});\n  useEffect(() => {\n    let cancelled = false;\n    setSyroProgress(0);\n    setSyroTransferState('idle');\n    setSyroAudioBuffer(null);\n    setCallbackOnSyroBuffer(null);\n    stop.current = () => {\n      cancelled = true;\n    };\n    try {\n      const { sampleBufferPromise, cancelWork } = getSampleBuffer(\n        sample,\n        (progress) => {\n          if (!cancelled) {\n            setSyroProgress(progress);\n          }\n        }\n      );\n      stop.current = () => {\n        cancelWork();\n        cancelled = true;\n      };\n      sampleBufferPromise.then(async (sampleBuffer) => {\n        if (cancelled) {\n          return;\n        }\n        stop.current = () => {\n          cancelled = true;\n        };\n        const audioBuffer = await getAudioBufferForAudioFileData(sampleBuffer);\n        if (!cancelled) {\n          setSyroAudioBuffer(audioBuffer);\n        }\n      });\n    } catch (err) {\n      console.error(err);\n      setSyroAudioBuffer(new Error(String(err)));\n    }\n    return () => stop.current();\n  }, [sample]);\n  const { playAudioBuffer } = useAudioPlaybackContext();\n  /** @type {React.MouseEventHandler} */\n  const handleTransfer = useCallback(\n    (e) => {\n      if (!(syroAudioBuffer instanceof AudioBuffer)) {\n        if (!syroAudioBuffer) {\n          const { target, nativeEvent } = e;\n          // wait until the syro buffer is ready then simulate the event to\n          // retry this handler. it's important that we simulate another\n          // action because otherwise iOS won't let us play the audio later.\n          setCallbackOnSyroBuffer({\n            fn: () => target.dispatchEvent(nativeEvent),\n          });\n        }\n        return;\n      }\n      try {\n        setSyroTransferState('transferring');\n        const stopPlayback = playAudioBuffer(syroAudioBuffer, {\n          onTimeUpdate: (currentTime) =>\n            setSyroProgress(currentTime / syroAudioBuffer.duration),\n          onEnded: () => setSyroTransferState('idle'),\n        });\n        stop.current = () => {\n          stopPlayback();\n          setSyroTransferState('idle');\n        };\n      } catch (err) {\n        console.error(err);\n        setSyroTransferState('error');\n      }\n    },\n    [playAudioBuffer, syroAudioBuffer]\n  );\n  const handleCancel = useCallback(() => stop.current(), []);\n  return (\n    <>\n      <Button\n        type=\"button\"\n        variant=\"primary\"\n        onClick={handleTransfer}\n        disabled={\n          syroAudioBuffer instanceof Error ||\n          syroTransferState === 'transferring'\n        }\n      >\n        Transfer to volca sample\n      </Button>\n      <br />\n      {syroAudioBuffer &&\n      syroTransferState === 'idle' ? null : syroTransferState === 'error' ? (\n        'Error transferring'\n      ) : (\n        <>\n          <p>\n            {!syroAudioBuffer\n              ? 'Preparing sample for transfer...'\n              : syroAudioBuffer instanceof AudioBuffer\n              ? 'Transferring to Volca Sample...'\n              : 'Error preparing sample for transfer'}\n          </p>\n          <ProgressBar now={100 * syroProgress} />\n          <br />\n          <Button type=\"button\" variant=\"light\" onClick={handleCancel}>\n            Cancel\n          </Button>\n        </>\n      )}\n      <br />\n    </>\n  );\n}\n\nexport default VolcaTransferControl;\n","import React, { useCallback, useEffect, useState } from 'react';\nimport { Form } from 'react-bootstrap';\nimport RangeSlider from 'react-bootstrap-range-slider';\n\nimport classes from './QualityBitDepthControl.module.scss';\n\nconst QualityBitDepthControl = React.memo(\n  /**\n   * @param {{\n   *   sampleId: string;\n   *   qualityBitDepth: number;\n   *   onSampleUpdate: (id: string, update: import('./store').SampleMetadataUpdateArg) => void;\n   * }} props\n   */\n  function QualityBitDepthControl({\n    sampleId,\n    qualityBitDepth,\n    onSampleUpdate,\n  }) {\n    const [localQualityBitDepth, setLocalQualityBitDepth] =\n      useState(qualityBitDepth);\n    useEffect(() => {\n      setLocalQualityBitDepth(qualityBitDepth);\n    }, [qualityBitDepth]);\n    /** @type {React.ChangeEventHandler<HTMLInputElement>} */\n    const handleChange = useCallback((e) => {\n      const qualityBitDepth = Number(e.target.value);\n      setLocalQualityBitDepth(qualityBitDepth);\n    }, []);\n    return (\n      <Form.Group className={classes.qualityBitDepthWrapper}>\n        <Form.Label className={classes.label}>Quality bit depth</Form.Label>\n        <div className={classes.ticks}>\n          {[8, 9, 10, 11, 12, 13, 14, 15, 16].map((value, i, { length }) => {\n            const left = `calc(${(i * 100) / (length - 1)}% + ${12 - 3 * i}px)`;\n            const hidden = localQualityBitDepth === value;\n            return (\n              <React.Fragment key={value}>\n                <label\n                  className={['small', classes.tickLabel].join(' ')}\n                  style={{\n                    left,\n                    visibility: hidden ? 'hidden' : undefined,\n                  }}\n                  onClick={() =>\n                    onSampleUpdate(sampleId, { qualityBitDepth: value })\n                  }\n                >\n                  {value}\n                </label>\n                <span\n                  className={classes.tickMark}\n                  style={{\n                    left,\n                    visibility: hidden ? 'hidden' : undefined,\n                  }}\n                />\n              </React.Fragment>\n            );\n          })}\n        </div>\n        <RangeSlider\n          value={localQualityBitDepth}\n          step={1}\n          min={8}\n          max={16}\n          size=\"lg\"\n          tooltip=\"on\"\n          tooltipPlacement=\"top\"\n          // fixes a z-fighting issue with other parts of the UI\n          tooltipStyle={{ zIndex: 1020 }}\n          onChange={handleChange}\n          ref={(input) =>\n            input &&\n            input.addEventListener('change', () => {\n              const qualityBitDepth = Number(input.value);\n              onSampleUpdate(sampleId, { qualityBitDepth });\n            })\n          }\n        />\n        <div className={classes.annotations}>\n          <label className=\"small\">Faster transfer</label>\n          <label className=\"small\">Higher quality</label>\n        </div>\n      </Form.Group>\n    );\n  }\n);\n\nexport default QualityBitDepthControl;\n","import React from 'react';\nimport { Form, OverlayTrigger, Tooltip } from 'react-bootstrap';\n\nimport classes from './NormalizeSwitch.module.scss';\n\nconst NormalizeSwitch = React.memo(\n  /**\n   * @param {{\n   *   sampleId: string;\n   *   normalize: boolean;\n   *   onSampleUpdate: (id: string, update: import('./store').SampleMetadataUpdateArg) => void;\n   * }} props\n   */\n  function NormalizeSwitch({ sampleId, normalize, onSampleUpdate }) {\n    return (\n      <Form.Group>\n        <OverlayTrigger\n          delay={{ show: 400, hide: 0 }}\n          overlay={\n            <Tooltip>\n              Boosts your sample's volume so its peak is at the same level as\n              your other normalized samples\n            </Tooltip>\n          }\n        >\n          <div className={classes.normalizeControlWrapper}>\n            <Form.Switch\n              label={\n                <span\n                  onClick={() =>\n                    onSampleUpdate(sampleId, (metadata) => ({\n                      normalize: !metadata.normalize,\n                    }))\n                  }\n                >\n                  Normalize\n                </span>\n              }\n              checked={normalize}\n              onChange={(e) =>\n                onSampleUpdate(sampleId, { normalize: e.target.checked })\n              }\n            />\n          </div>\n        </OverlayTrigger>\n      </Form.Group>\n    );\n  }\n);\n\nexport default NormalizeSwitch;\n","import React, { useCallback, useEffect, useRef, useState } from 'react';\nimport SevenSegmentDisplay, { Digit } from 'seven-segment-display';\nimport { Form, OverlayTrigger, Tooltip } from 'react-bootstrap';\nimport { findDOMNode } from 'react-dom';\nimport keyboardArrowUpIcon from '@material-design-icons/svg/filled/keyboard_arrow_up.svg';\nimport keyboardArrowDownIcon from '@material-design-icons/svg/filled/keyboard_arrow_down.svg';\nimport warningIcon from '@material-design-icons/svg/filled/warning.svg';\n\nimport classes from './SlotNumberInput.module.scss';\n\nDigit.defaultProps.offOpacity = 0;\n\n/** @typedef {(slotNumber: number) => number} SlotNumberCallback */\n\n/**\n * @param {0 | 1 | 2} digit\n * @param {number} slotNumber\n * */\nconst arrowUpCallback = (digit, slotNumber) =>\n  Math.min(199, slotNumber + 10 ** digit);\n\n/**\n * @param {0 | 1 | 2} digit\n * @param {number} slotNumber\n * */\nconst arrowDownCallback = (digit, slotNumber) =>\n  Math.max(0, slotNumber - 10 ** digit);\n\nconst SlotNumberInput = React.memo(\n  /**\n   * @param {{\n   *   slotNumber: number;\n   *   onSlotNumberUpdate: (update: number | ((slotNumber: number) => number)) => void;\n   * }} props\n   */\n  function ({ slotNumber, onSlotNumberUpdate }) {\n    const [slotNumberLocal, setSlotNumberLocal] = useState(slotNumber);\n    useEffect(() => {\n      setSlotNumberLocal(slotNumber);\n    }, [slotNumber]);\n\n    // 0 is 0-9, 1 is 0-90, 2 is 0-200\n    const [focusedDigit, setFocusedDigit] = useState(\n      /** @type {0 | 1 | 2 | null} */ (null)\n    );\n\n    /** @type {(digit: 0 | 1 | 2) => void} */\n    const handleArrowUp = useCallback(\n      (digit) => {\n        onSlotNumberUpdate((slotNumber) => arrowUpCallback(digit, slotNumber));\n      },\n      [onSlotNumberUpdate]\n    );\n\n    /** @type {(digit: 0 | 1 | 2) => void} */\n    const handleArrowDown = useCallback(\n      (digit) => {\n        onSlotNumberUpdate((slotNumber) =>\n          arrowDownCallback(digit, slotNumber)\n        );\n      },\n      [onSlotNumberUpdate]\n    );\n\n    /**\n     * @type {React.RefObject<HTMLDivElement>}\n     */\n    const slotNumberRef = useRef(null);\n    const digitElementsRef = useRef(/** @type {SVGGElement[] | null} */ (null));\n    {\n      const focusedDigitRef = useRef(focusedDigit);\n      focusedDigitRef.current = focusedDigit;\n      const slotNumberLocalRef = useRef(slotNumberLocal);\n      slotNumberLocalRef.current = slotNumberLocal;\n      useEffect(() => {\n        if (!digitElementsRef.current) {\n          throw new Error('Expected elements to exist');\n        }\n        /** @param {KeyboardEvent} e */\n        function onKeyDown(e) {\n          const focusedDigit =\n            focusedDigitRef.current === null ? 0 : focusedDigitRef.current;\n          let handled = true;\n          const beforeArrowAction = () => {\n            setFocusedDigit(focusedDigit);\n          };\n          switch (e.key) {\n            // slot number down\n            case 'ArrowDown':\n              beforeArrowAction();\n              setSlotNumberLocal((slotNumber) =>\n                arrowDownCallback(focusedDigit, slotNumber)\n              );\n              break;\n            // slot number up\n            case 'ArrowUp':\n              beforeArrowAction();\n              setSlotNumberLocal((slotNumber) =>\n                arrowUpCallback(focusedDigit, slotNumber)\n              );\n              break;\n            // digit navigation left\n            case 'ArrowLeft':\n              beforeArrowAction();\n              setFocusedDigit((digit) =>\n                digit !== null && digit < 2\n                  ? /** @type {1 | 2} */ (digit + 1)\n                  : digit\n              );\n              break;\n            // digit navigation right\n            case 'ArrowRight':\n              beforeArrowAction();\n              setFocusedDigit((digit) =>\n                digit ? /** @type {0 | 1} */ (digit - 1) : digit\n              );\n              break;\n            case 'Enter':\n            case 'Escape':\n              setFocusedDigit(null);\n              break;\n            default:\n              handled = false;\n              break;\n          }\n          if (handled) {\n            e.preventDefault();\n          }\n        }\n        /** @param {KeyboardEvent} e */\n        function onKeyUp(e) {\n          const focusedDigit =\n            focusedDigitRef.current === null ? 2 : focusedDigitRef.current;\n          e.stopPropagation();\n          e.preventDefault();\n          const slotNumber = slotNumberLocalRef.current;\n          if (!isNaN(Number(e.key))) {\n            // numberPressed is a digit 0-9\n            const chars = String(slotNumber).padStart(3, '0').split('');\n            chars[2 - focusedDigit] = e.key;\n            const newSlotNumber = Math.min(\n              199,\n              Math.max(0, Number(chars.join('')))\n            );\n            setFocusedDigit(\n              focusedDigit ? /** @type {0 | 1} */ (focusedDigit - 1) : null\n            );\n            onSlotNumberUpdate(newSlotNumber);\n          } else {\n            onSlotNumberUpdate(slotNumber);\n          }\n        }\n        const slotNumberElement = /** @type {HTMLDivElement} */ (\n          slotNumberRef.current\n        );\n        slotNumberElement.addEventListener('keydown', onKeyDown, true);\n        slotNumberElement.addEventListener('keyup', onKeyUp, true);\n        let pageYStart = 0;\n        let mousedown = false;\n        let slotNumberDragged = false;\n        let slotNumberStart = 0;\n        /**\n         * @param {MouseEvent | TouchEvent} e\n         */\n        function handleMouseDown(e) {\n          document.body.style.userSelect = 'none';\n          pageYStart = e instanceof MouseEvent ? e.pageY : e.touches[0].pageY;\n          mousedown = true;\n          slotNumberDragged = false;\n          slotNumberStart = slotNumberLocalRef.current;\n        }\n        slotNumberElement.addEventListener('mousedown', handleMouseDown);\n        slotNumberElement.addEventListener('touchstart', (e) => {\n          e.preventDefault();\n          handleMouseDown(e);\n        });\n        /**\n         * @param {MouseEvent | TouchEvent} e\n         */\n        function handleMouseMove(e) {\n          if (!mousedown) {\n            return;\n          }\n          const { pageY } = e instanceof MouseEvent ? e : e.touches[0];\n          const pixelsPerIncrement = 2;\n          const increment = Math.round(\n            (pageYStart - pageY) / pixelsPerIncrement\n          );\n          if (increment) {\n            slotNumberDragged = true;\n            setSlotNumberLocal(\n              Math.min(199, Math.max(0, slotNumberStart + increment))\n            );\n          }\n        }\n        window.addEventListener('mousemove', handleMouseMove);\n        slotNumberElement.addEventListener('touchmove', handleMouseMove);\n        function handleMouseUp() {\n          document.body.style.userSelect = 'unset';\n          mousedown = false;\n          if (slotNumberDragged) {\n            onSlotNumberUpdate(slotNumberLocalRef.current);\n          }\n        }\n        window.addEventListener('mouseup', handleMouseUp);\n        slotNumberElement.addEventListener('touchend', handleMouseUp);\n        slotNumberElement.addEventListener('touchcancel', () => {\n          document.body.style.userSelect = 'unset';\n        });\n        /** @param {MouseEvent} e */\n        function handleClick(e) {\n          if (\n            slotNumberDragged ||\n            (digitElementsRef.current &&\n              digitElementsRef.current.some((elem) =>\n                elem.contains(/** @type {Node} */ (e.target))\n              ))\n          ) {\n            return;\n          }\n          setFocusedDigit(2);\n        }\n        slotNumberElement.addEventListener('click', handleClick);\n        digitElementsRef.current.forEach((element, i) => {\n          const digit = /** @type {0 | 1 | 2} */ (i);\n          element.addEventListener('click', () => {\n            if (!slotNumberDragged) {\n              setFocusedDigit(digit);\n            }\n          });\n          element.addEventListener('touchstart', (e) => {\n            e.preventDefault();\n          });\n        });\n        function handleFocus() {\n          if (mousedown) {\n            // we already handle this for mouse events\n            return;\n          }\n          setFocusedDigit(2);\n        }\n        function handleBlur() {\n          setFocusedDigit(null);\n        }\n        slotNumberElement.addEventListener('focus', handleFocus);\n        slotNumberElement.addEventListener('blur', handleBlur);\n        return () => {\n          window.removeEventListener('mousemove', handleMouseMove);\n          window.removeEventListener('mouseup', handleMouseUp);\n        };\n      }, [onSlotNumberUpdate]);\n    }\n    useEffect(() => {\n      if (!digitElementsRef.current) {\n        throw new Error('Expected elements to exist');\n      }\n      digitElementsRef.current.forEach((element, i) => {\n        if (i === focusedDigit) {\n          element.classList.add(classes.active);\n        } else {\n          element.classList.remove(classes.active);\n        }\n      });\n    }, [focusedDigit]);\n    return (\n      <>\n        <Form.Label>Destination</Form.Label>\n        <br />\n        <div className={classes.slotNumberRow}>\n          <div className={classes.slotNumberContainer}>\n            <div className={classes.arrowControls}>\n              <span onClick={() => handleArrowUp(2)}>\n                <img src={keyboardArrowUpIcon} alt=\"Increment 100\" />\n              </span>\n              <span onClick={() => handleArrowUp(1)}>\n                <img src={keyboardArrowUpIcon} alt=\"Increment 10\" />\n              </span>\n              <span onClick={() => handleArrowUp(0)}>\n                <img src={keyboardArrowUpIcon} alt=\"Increment 1\" />\n              </span>\n            </div>\n            <div\n              className={classes.slotNumber}\n              title={`Slot ${slotNumberLocal}`}\n              ref={slotNumberRef}\n              tabIndex={0}\n            >\n              {/* behind the real information we just put a row of faint 8s to\n        simulate the effect of unilluminated character segments */}\n              <SevenSegmentDisplay\n                value=\"8888\"\n                color=\"var(--bs-gray-dark)\"\n                strokeColor=\"transparent\"\n                digitCount={4}\n              />\n              <SevenSegmentDisplay\n                ref={\n                  /**\n                   * @param {React.Component} instance\n                   */\n                  (instance) => {\n                    const svg = /** @type {SVGElement} */ (\n                      findDOMNode(instance)\n                    );\n                    if (svg) {\n                      svg.querySelectorAll('circle').forEach((oldPoint) => {\n                        svg.removeChild(oldPoint);\n                      });\n                      const point = document.createElementNS(\n                        'http://www.w3.org/2000/svg',\n                        'circle'\n                      );\n                      point.classList.add(classes.point);\n                      point.setAttribute('cx', '10.7');\n                      point.setAttribute('cy', '17');\n                      point.setAttribute('r', '1');\n                      svg.appendChild(point);\n\n                      digitElementsRef.current = /** @type {SVGGElement[]} */ (\n                        [].slice.call(svg.querySelectorAll('g'))\n                      )\n                        // call .reverse() to get the right-most (smallest) digit first\n                        .reverse()\n                        .slice(0, 3);\n                    }\n                  }\n                }\n                // the 5 actually represents an S\n                value={`5${String(slotNumberLocal).padStart(3, '0')}`}\n                digitProps={{ color: 'var(--bs-primary)' }}\n                digitCount={4}\n              />\n            </div>\n            <div className={classes.arrowControls}>\n              <span onClick={() => handleArrowDown(2)}>\n                <img src={keyboardArrowDownIcon} alt=\"Decrement 100\" />\n              </span>\n              <span onClick={() => handleArrowDown(1)}>\n                <img src={keyboardArrowDownIcon} alt=\"Decrement 10\" />\n              </span>\n              <span onClick={() => handleArrowDown(0)}>\n                <img src={keyboardArrowDownIcon} alt=\"Decrement 1\" />\n              </span>\n            </div>\n          </div>\n          {slotNumber > 99 && slotNumberLocal > 99 && (\n            <OverlayTrigger\n              placement=\"auto-end\"\n              overlay={\n                <Tooltip>\n                  To transfer to this destination, be sure you have a volca\n                  sample2. The original volca sample only supports slots 0-99.\n                </Tooltip>\n              }\n            >\n              <img\n                className={classes.warning}\n                src={warningIcon}\n                alt=\"destination-warning\"\n              />\n            </OverlayTrigger>\n          )}\n        </div>\n      </>\n    );\n  }\n);\n\nexport default SlotNumberInput;\n","import React, { useCallback, useEffect, useState } from 'react';\nimport {\n  Container,\n  Dropdown,\n  DropdownButton,\n  Button,\n} from 'react-bootstrap';\n\nimport WaveformEdit from './WaveformEdit.js';\nimport VolcaTransferControl from './VolcaTransferControl.js';\nimport {\n  getTargetWavForSample,\n  getAudioBufferForAudioFileData,\n} from './utils/audioData.js';\nimport { SampleContainer } from './store.js';\nimport QualityBitDepthControl from './QualityBitDepthControl.js';\nimport NormalizeSwitch from './NormalizeSwitch.js';\nimport SlotNumberInput from './SlotNumberInput.js';\n\nimport classes from './SampleDetail.module.scss';\n\n/**\n * @param {Blob} blob\n * @param {string} filename\n */\nfunction downloadBlob(blob, filename) {\n  const url = URL.createObjectURL(blob);\n  const a = document.createElement('a');\n  a.href = url;\n  a.download = filename;\n  a.style.display = 'none';\n  document.body.appendChild(a);\n  a.click();\n  a.remove();\n  URL.revokeObjectURL(url);\n}\n\nconst SampleDetail = React.memo(\n  /**\n   * @param {{\n   *   sample: import('./store').SampleContainer;\n   *   onSampleUpdate: (id: string, update: import('./store').SampleMetadataUpdateArg) => void;\n   *   onSampleDuplicate: (id: string) => void;\n   *   onSampleDelete: (id: string) => void;\n   * }} props\n   */\n  function SampleDetail({\n    sample,\n    onSampleUpdate,\n    onSampleDuplicate,\n    onSampleDelete,\n  }) {\n    const sampleId = sample && sample.id;\n    /**\n     * @type {(updateTrimFrames: (old: [number, number]) => [number, number]) => void}\n     */\n    const handleSetTrimFrames = useCallback(\n      (updateTrimFrames) =>\n        sampleId &&\n        onSampleUpdate(sampleId, (metadata) => ({\n          ...metadata,\n          trim: {\n            ...metadata.trim,\n            frames: updateTrimFrames(metadata.trim.frames),\n          },\n        })),\n      [sampleId, onSampleUpdate]\n    );\n    const [targetWav, setTargetWav] = useState(\n      /** @type {Uint8Array | null} */ (null)\n    );\n    const [audioBufferForAudioFileData, setAudioBufferForAudioFileData] =\n      useState(/** @type {AudioBuffer | null} */ (null));\n    const [callbackOnAudioBuffer, setCallbackOnAudioBuffer] = useState(\n      /** @type {{ fn: () => void } | null} */ (null)\n    );\n    useEffect(() => {\n      if (\n        audioBufferForAudioFileData instanceof AudioBuffer &&\n        callbackOnAudioBuffer\n      ) {\n        setCallbackOnAudioBuffer(null);\n        callbackOnAudioBuffer.fn();\n      }\n    }, [audioBufferForAudioFileData, callbackOnAudioBuffer]);\n    useEffect(() => {\n      setTargetWav(null);\n      setCallbackOnAudioBuffer(null);\n      let cancelled = false;\n      getTargetWavForSample(sample).then(({ data }) => {\n        if (!cancelled) {\n          setTargetWav(data);\n        }\n      });\n    }, [sample]);\n    useEffect(() => {\n      setAudioBufferForAudioFileData(null);\n      if (targetWav) {\n        let cancelled = false;\n        getAudioBufferForAudioFileData(targetWav).then((audioBuffer) => {\n          if (!cancelled) {\n            setAudioBufferForAudioFileData(audioBuffer);\n          }\n        });\n      }\n    }, [targetWav]);\n    /**\n     * @type {(update: number | ((slotNumber: number) => number)) => void}\n     */\n    const handleSlotNumberUpdate = useCallback(\n      (update) => {\n        onSampleUpdate(sample.id, ({ slotNumber }) => ({\n          slotNumber:\n            typeof update === 'function' ? update(slotNumber) : update,\n        }));\n      },\n      [sample.id, onSampleUpdate]\n    );\n    return (\n      <Container fluid=\"sm\">\n        <h2>\n          {sample.metadata.name}\n          <SampleDetailActions\n            sampleId={sample.id}\n            name={sample.metadata.name}\n            onSampleUpdate={onSampleUpdate}\n            onSampleDuplicate={onSampleDuplicate}\n            onSampleDelete={onSampleDelete}\n          />\n        </h2>\n        <p>\n          <strong>Sampled:</strong>{' '}\n          {new Date(sample.metadata.dateSampled).toLocaleString()}\n          <br />\n          <strong>Updated:</strong>{' '}\n          {new Date(sample.metadata.dateModified).toLocaleString()}\n        </p>\n        <br />\n        <QualityBitDepthControl\n          sampleId={sample.id}\n          qualityBitDepth={sample.metadata.qualityBitDepth}\n          onSampleUpdate={onSampleUpdate}\n        />\n        <NormalizeSwitch\n          sampleId={sample.id}\n          normalize={sample.metadata.normalize}\n          onSampleUpdate={onSampleUpdate}\n        />\n        <div className={classes.waveformBoundingBox}>\n          <WaveformEdit\n            onSetTrimFrames={handleSetTrimFrames}\n            sample={sample}\n            previewWav={audioBufferForAudioFileData}\n          />\n        </div>\n        {/* {' '}\n      <Button\n        type=\"button\"\n        variant=\"secondary\"\n        onClick={async () => {\n          if (targetWav) {\n            const blob = new Blob([targetWav], {\n              type: 'audio/x-wav',\n            });\n            downloadBlob(blob, `${sample.metadata.name}.wav`);\n          }\n        }}\n        disabled={!targetWav}\n      >\n        Download preview audio\n      </Button> */}{' '}\n        <Button\n          type=\"button\"\n          variant=\"secondary\"\n          size=\"sm\"\n          onClick={async () => {\n            const { sourceFileId, userFileInfo } = sample.metadata;\n            const data = await SampleContainer.getSourceFileData(sourceFileId);\n            const blob = new Blob([data], {\n              type: userFileInfo ? userFileInfo.type : 'audio/x-wav',\n            });\n            downloadBlob(\n              blob,\n              `${sample.metadata.name}${\n                userFileInfo ? userFileInfo.ext : '.wav'\n              }`\n            );\n          }}\n        >\n          Download original file\n        </Button>\n        <br />\n        <br />\n        <SlotNumberInput\n          slotNumber={sample.metadata.slotNumber}\n          onSlotNumberUpdate={handleSlotNumberUpdate}\n        />\n        <VolcaTransferControl sample={sample} />\n      </Container>\n    );\n  }\n);\n\nconst SampleDetailActions = React.memo(\n  /**\n   * @param {{\n   *   sampleId: string;\n   *   name: string;\n   *   onSampleUpdate: (id: string, update: import('./store').SampleMetadataUpdateArg) => void;\n   *   onSampleDuplicate: (id: string) => void;\n   *   onSampleDelete: (id: string) => void;\n   * }} props\n   */\n  ({ sampleId, name, onSampleUpdate, onSampleDuplicate, onSampleDelete }) => {\n    return (\n      <DropdownButton\n        className={classes.optionsButton}\n        variant=\"light\"\n        align=\"end\"\n        title=\"options\"\n      >\n        <Dropdown.Item\n          onClick={() => {\n            const newName = prompt(\n              `Choose a new name for the sample \"${name}\":`,\n              name\n            );\n            const newNameTrimmed = newName && newName.trim();\n            if (newNameTrimmed) {\n              onSampleUpdate(sampleId, { name: newNameTrimmed });\n            }\n          }}\n        >\n          Rename\n        </Dropdown.Item>\n        <Dropdown.Item onClick={() => onSampleDuplicate(sampleId)}>\n          Duplicate\n        </Dropdown.Item>\n        <Dropdown.Divider />\n        <Dropdown.Item\n          onClick={() => {\n            if (window.confirm(`Are you sure you want to delete ${name}?`)) {\n              onSampleDelete(sampleId);\n            }\n          }}\n        >\n          Delete\n        </Dropdown.Item>\n      </DropdownButton>\n    );\n  }\n);\n\nexport default SampleDetail;\n","import React, { useMemo } from 'react';\nimport { findSamplePeak, getTrimmedView } from './utils/audioData.js';\n\nimport { useLoadedSample, useWaveformInfo } from './utils/waveform.js';\nimport WaveformDisplay from './WaveformDisplay.js';\n\n/**\n * @typedef {{\n *   sample: import('./store').SampleContainer;\n * }} WaveformReadonlyProps\n */\n\n/**\n * @param {WaveformReadonlyProps} props\n */\nfunction WaveformReadonly({ sample: _sample }) {\n  const {\n    sample: {\n      metadata: { normalize, trim: { frames: trimFrames } },\n    },\n    sourceAudioBuffer,\n  } = useLoadedSample(_sample);\n  const { monoSamples, waveformRef, peaks } = useWaveformInfo(sourceAudioBuffer);\n\n  const trimmedSamplePeak = useMemo(() => {\n    if (!sourceAudioBuffer) {\n      return 0;\n    }\n    const trimmedView = getTrimmedView(monoSamples, trimFrames);\n    const samplePeak = findSamplePeak(trimmedView);\n    return samplePeak;\n  }, [sourceAudioBuffer, monoSamples, trimFrames]);\n\n  const normalizationCoefficient = 1 / trimmedSamplePeak;\n\n  return (\n    <div style={{ backgroundColor: '#f3f3f3' }}>\n      <WaveformDisplay\n        waveformRef={waveformRef}\n        peaks={peaks}\n        scaleCoefficient={normalize ? normalizationCoefficient : 1}\n      />\n    </div>\n  );\n}\n\nexport default WaveformReadonly;\n","import React, { useEffect, useMemo, useRef, useState } from 'react';\nimport { Container, Button, Form, Alert } from 'react-bootstrap';\n\nimport WaveformReadonly from './WaveformReadonly.js';\nimport VolcaTransferControl from './VolcaTransferControl.js';\nimport {\n  getTargetWavForSample,\n  getAudioBufferForAudioFileData,\n  useAudioPlaybackContext,\n} from './utils/audioData.js';\nimport { SampleContainer } from './store.js';\nimport SlotNumberInput from './SlotNumberInput.js';\n\nimport classes from './SampleDetail.module.scss';\n\n/**\n * @param {Blob} blob\n * @param {string} filename\n */\nfunction downloadBlob(blob, filename) {\n  const url = URL.createObjectURL(blob);\n  const a = document.createElement('a');\n  a.href = url;\n  a.download = filename;\n  a.style.display = 'none';\n  document.body.appendChild(a);\n  a.click();\n  a.remove();\n  URL.revokeObjectURL(url);\n}\n\n/**\n * @param {import('./store').SampleContainer} readonlySample\n */\nfunction useSampleWithTemporalSlotNumber(readonlySample) {\n  const readonlySlotNumber = readonlySample.metadata.slotNumber;\n  const [slotNumber, setSlotNumber] = useState(readonlySlotNumber);\n  useEffect(() => {\n    setSlotNumber(readonlySlotNumber);\n  }, [readonlySlotNumber]);\n  const sample = useMemo(\n    () =>\n      readonlySample &&\n      new SampleContainer({\n        id: readonlySample.id,\n        ...readonlySample.metadata,\n        slotNumber,\n      }),\n    [readonlySample, slotNumber]\n  );\n  return { sample, setSlotNumber };\n}\n\n/**\n * @param {{\n *   sample: import('./store').SampleContainer;\n *   onSampleDuplicate: (id: string) => void;\n * }} props\n */\nfunction SampleDetailReadonly({ sample: readonlySample, onSampleDuplicate }) {\n  const { sample, setSlotNumber } =\n    useSampleWithTemporalSlotNumber(readonlySample);\n  const [targetWav, setTargetWav] = useState(\n    /** @type {Uint8Array | null} */ (null)\n  );\n  const [audioBufferForAudioFileData, setAudioBufferForAudioFileData] =\n    useState(/** @type {AudioBuffer | null} */ (null));\n  const [callbackOnAudioBuffer, setCallbackOnAudioBuffer] = useState(\n    /** @type {{ fn: () => void } | null} */ (null)\n  );\n  useEffect(() => {\n    if (\n      audioBufferForAudioFileData instanceof AudioBuffer &&\n      callbackOnAudioBuffer\n    ) {\n      setCallbackOnAudioBuffer(null);\n      callbackOnAudioBuffer.fn();\n    }\n  }, [audioBufferForAudioFileData, callbackOnAudioBuffer]);\n  useEffect(() => {\n    setTargetWav(null);\n    setCallbackOnAudioBuffer(null);\n    let cancelled = false;\n    getTargetWavForSample(sample).then(({ data }) => {\n      if (!cancelled) {\n        setTargetWav(data);\n      }\n    });\n  }, [sample]);\n  useEffect(() => {\n    setAudioBufferForAudioFileData(null);\n    if (targetWav) {\n      let cancelled = false;\n      getAudioBufferForAudioFileData(targetWav).then((audioBuffer) => {\n        if (!cancelled) {\n          setAudioBufferForAudioFileData(audioBuffer);\n        }\n      });\n    }\n  }, [targetWav]);\n  const { playAudioBuffer } = useAudioPlaybackContext();\n  // to be set when playback is started\n  const stopPreviewPlayback = useRef(() => {});\n  useEffect(() => {\n    return () => stopPreviewPlayback.current();\n  }, [sample]);\n  return (\n    <Container fluid=\"sm\">\n      <h2>{sample.metadata.name}</h2>\n      <p>\n        <strong>Sampled:</strong>{' '}\n        {new Date(sample.metadata.dateSampled).toLocaleString()}\n      </p>\n      <Alert variant=\"secondary\">\n        <Alert.Heading>This is a factory sample.</Alert.Heading>\n        <p>\n          If you want to trim the audio, change volume or adjust quality before\n          transferring to the volca sample,{' '}\n          <span className={classes.buttonLink}>\n            <Button variant=\"link\" onClick={() => onSampleDuplicate(sample.id)}>\n              make a duplicate\n            </Button>\n            .\n          </span>\n        </p>\n      </Alert>\n      <div className={classes.waveformContainer}>\n        <WaveformReadonly sample={sample} />\n      </div>\n      <br />\n      <br />\n      <Button\n        type=\"button\"\n        variant=\"secondary\"\n        size=\"sm\"\n        onClick={(e) => {\n          if (audioBufferForAudioFileData) {\n            stopPreviewPlayback.current = playAudioBuffer(\n              audioBufferForAudioFileData\n            );\n          } else {\n            const button = e.currentTarget;\n            // wait until the audio buffer is ready then simulate a click event\n            // to retry this handler. it's important that we simulate another\n            // click because otherwise iOS won't let us play the audio later.\n            setCallbackOnAudioBuffer({ fn: () => button.click() });\n          }\n        }}\n      >\n        Play audio preview\n      </Button>\n      {/* {' '}\n      <Button\n        type=\"button\"\n        variant=\"secondary\"\n        onClick={async () => {\n          if (targetWav) {\n            const blob = new Blob([targetWav], {\n              type: 'audio/x-wav',\n            });\n            downloadBlob(blob, `${sample.metadata.name}.wav`);\n          }\n        }}\n        disabled={!targetWav}\n      >\n        Download preview audio\n      </Button> */}{' '}\n      <Button\n        type=\"button\"\n        variant=\"secondary\"\n        size=\"sm\"\n        onClick={async () => {\n          const { sourceFileId, userFileInfo } = sample.metadata;\n          const data = await SampleContainer.getSourceFileData(sourceFileId);\n          const blob = new Blob([data], {\n            type: userFileInfo ? userFileInfo.type : 'audio/x-wav',\n          });\n          downloadBlob(\n            blob,\n            `${sample.metadata.name}${userFileInfo ? userFileInfo.ext : '.wav'}`\n          );\n        }}\n      >\n        Download original file\n      </Button>\n      <br />\n      <br />\n      <Form.Group>\n        <Form.Label>\n          Quality bit depth ({sample.metadata.qualityBitDepth})\n        </Form.Label>\n        <Form.Range\n          disabled\n          value={sample.metadata.qualityBitDepth}\n          step={1}\n          min={8}\n          max={16}\n        />\n      </Form.Group>\n      <SlotNumberInput\n        slotNumber={sample.metadata.slotNumber}\n        onSlotNumberUpdate={setSlotNumber}\n      />\n      <br />\n      <VolcaTransferControl sample={sample} />\n    </Container>\n  );\n}\n\nexport default SampleDetailReadonly;\n","import getWavFileHeaders from 'wav-headers';\n\nimport {\n  clampOutOfBoundsValues,\n  convertSamplesTo16Bit,\n  getAudioContextConstructor,\n  interleaveSampleChannels,\n} from './audioData.js';\nimport { SAMPLE_RATE } from './constants.js';\n\n/**\n * @type {AudioContext | undefined}\n */\nlet recordingAudioContext;\n\nfunction getRecordingAudioContext() {\n  const AudioContext = getAudioContextConstructor();\n  return (recordingAudioContext =\n    recordingAudioContext ||\n    new AudioContext(\n      navigator.mediaDevices.getSupportedConstraints().sampleRate\n        ? { sampleRate: SAMPLE_RATE }\n        : {}\n    ));\n}\n\n/**\n * @typedef {{ device: { deviceId: string; label: string }; channelsAvailable: number }} AudioDeviceInfoContainer\n */\n\n/**\n * @returns {Promise<AudioDeviceInfoContainer[]>}\n */\nexport async function getAudioInputDevices() {\n  {\n    // request dummy stream first on the first available input device. this is\n    // because some platforms (like iOS) don't allow any kind of device\n    // inspection until access has been given to a media stream.\n    const stream = await navigator.mediaDevices.getUserMedia({\n      audio: true,\n      video: false,\n    });\n    for (const track of stream.getTracks()) {\n      track.stop();\n    }\n  }\n  const devices = await navigator.mediaDevices.enumerateDevices();\n  const audioInputDevices = devices.filter(\n    (device) => device.kind === 'audioinput'\n  );\n  /**\n   * @type {AudioDeviceInfoContainer[]}\n   */\n  const infoContainers = [];\n  for (const device of audioInputDevices) {\n    const stream = await navigator.mediaDevices.getUserMedia({\n      // try to grab stereo audio\n      audio: { deviceId: device.deviceId, channelCount: 2 },\n      video: false,\n    });\n    // for Firefox, which requires us to check this info after\n    // permissions have been granted\n    const realLabel = /** @type {MediaDeviceInfo} */ (\n      (await navigator.mediaDevices.enumerateDevices()).find(\n        ({ deviceId }) => device.deviceId === deviceId\n      )\n    ).label;\n    let channelsAvailable = 1;\n    {\n      const track = stream.getAudioTracks()[0];\n      // not widely available yet according to MDN.. but at least\n      // seems to work with all the latest versions of each browser\n      const channelCountSetting =\n        /** @type {MediaTrackSettings & { channelCount: number }} */ (\n          track.getSettings()\n        ).channelCount;\n      if (channelCountSetting) {\n        channelsAvailable = channelCountSetting;\n      } else if (track.getCapabilities) {\n        // we'll try this as backup if it exists since the API is older, but\n        // also not supported by Firefox\n        channelsAvailable =\n          (track.getCapabilities().channelCount || {}).max || channelsAvailable;\n      }\n    }\n    for (const track of stream.getTracks()) {\n      track.stop();\n    }\n    infoContainers.push({\n      device: { deviceId: device.deviceId, label: realLabel },\n      channelsAvailable,\n    });\n  }\n  return infoContainers;\n}\n\n/**\n * @typedef {Omit<AudioWorkletNode, 'parameters'> & {\n *   parameters: Map<'isRecording' | 'bufferSize', AudioParam>\n * }} TAudioWorkletNode\n */\n\n/**\n * @typedef {{\n *  channelCount: number;\n *  onData: (audioChannels: Float32Array[]) => void;\n *  onFinish: () => void;\n * }} PcmRecorderNodeOptions\n */\n\n/**\n * @type {Promise<void> | undefined}\n */\nlet recorderWorkletProcessorPromise;\n/**\n * @param {PcmRecorderNodeOptions} options\n * @returns {Promise<{ recorderNode: TAudioWorkletNode; stop: () => void }>}\n */\nasync function createAudioWorkletPcmRecorderNode({ onData, onFinish }) {\n  const audioContext = getRecordingAudioContext();\n  recorderWorkletProcessorPromise =\n    recorderWorkletProcessorPromise ||\n    audioContext.audioWorklet.addModule('recorderWorkletProcessor.js');\n  await recorderWorkletProcessorPromise;\n  const recorderNode = /** @type {TAudioWorkletNode} */ (\n    new AudioWorkletNode(audioContext, 'recorder-worklet', {\n      parameterData: {\n        bufferSize: 1024,\n      },\n    })\n  );\n  recorderNode.port.onmessage = (e) => {\n    if (e.data.eventType === 'data') {\n      /**\n       * @type {Float32Array[]}\n       */\n      const audioChannels = e.data.audioChannels;\n      onData(audioChannels);\n    }\n\n    if (e.data.eventType === 'stop') {\n      onFinish();\n    }\n  };\n  const isRecordingParam = /** @type {AudioParam} */ (\n    recorderNode.parameters.get('isRecording')\n  );\n  isRecordingParam.setValueAtTime(1, audioContext.currentTime);\n  return {\n    recorderNode,\n    stop() {\n      isRecordingParam.setValueAtTime(0, audioContext.currentTime);\n    },\n  };\n}\n\n/**\n * @param {PcmRecorderNodeOptions} options\n * @returns {{ recorderNode: ScriptProcessorNode; stop: () => void }}\n */\nfunction createScriptProcessorPcmRecorderNode({\n  channelCount,\n  onData,\n  onFinish,\n}) {\n  const audioContext = getRecordingAudioContext();\n  const recorderNode = audioContext.createScriptProcessor(\n    1024,\n    channelCount,\n    channelCount\n  );\n  // to be set by user if they want to stop recording before time limit reached\n  let stopped = false;\n  recorderNode.onaudioprocess = (e) => {\n    const audioChannels = /** @type {void[]} */ (Array(channelCount))\n      .fill()\n      .map((_, i) => e.inputBuffer.getChannelData(i));\n    onData(audioChannels);\n    if (stopped) {\n      onFinish();\n    }\n  };\n  return {\n    recorderNode,\n    stop() {\n      stopped = true;\n    },\n  };\n}\n\n/**\n * @param {PcmRecorderNodeOptions} options\n * @returns {Promise<{ recorderNode: AudioNode; stop: () => void }>}\n */\nasync function createPcmRecorderNode(options) {\n  if (typeof AudioWorkletNode === 'undefined') {\n    return createScriptProcessorPcmRecorderNode(options);\n  }\n  return await createAudioWorkletPcmRecorderNode(options);\n}\n\n/**\n * @param {{\n *   deviceId: string;\n *   channelCount: number;\n *   onStart: (sampleRate: number, timeLimitSeconds: number) => void;\n *   onUpdate: (floatChunksByChannel: Float32Array[]) => void;\n * }} options\n * @returns {Promise<{ mediaRecording: Promise<Uint8Array>; stop: () => void }>}\n */\nexport async function captureAudio({\n  deviceId,\n  channelCount,\n  onStart,\n  onUpdate,\n}) {\n  const stream = await navigator.mediaDevices.getUserMedia({\n    // TODO: support more recording configuration options\n    // https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints#properties_of_audio_tracks\n    // autoGainControl, echoCancellation, latency, noiseSuppression, volume\n    audio: {\n      deviceId,\n      channelCount,\n      sampleRate: SAMPLE_RATE,\n      echoCancellation: false,\n      // TODO: add advanced controls for these options\n      // @ts-ignore (should be in type)\n      autoGainControl: false,\n      noiseSuppression: false,\n    },\n    video: false,\n  });\n  const audioContext = getRecordingAudioContext();\n  const mediaStreamSourceNode = audioContext.createMediaStreamSource(stream);\n  const { recorderNode, stop } = await createPcmRecorderNode({\n    channelCount,\n    onData,\n    onFinish,\n  });\n  mediaStreamSourceNode.connect(recorderNode);\n  recorderNode.connect(audioContext.destination);\n  const timeLimitSeconds = 10;\n  onStart(audioContext.sampleRate, timeLimitSeconds);\n\n  const maxSamples = timeLimitSeconds * audioContext.sampleRate;\n  let samplesRecorded = 0;\n  /**\n   * @type {Int16Array[]}\n   */\n  const recordedChunks = Array(channelCount).fill([]);\n\n  /**\n   * @param {Float32Array[]} audioChannels\n   */\n  function onData(audioChannels) {\n    /**\n     * @type {number}\n     */\n    let sampleCount = 0;\n    /**\n     * @type {Float32Array[]}\n     */\n    const floatChunksByChannel = [];\n    for (let channel = 0; channel < channelCount; channel++) {\n      const chunk = audioChannels[channel];\n      const chunkSize = chunk.length;\n      const chunkSliced = chunk.slice(\n        0,\n        Math.min(chunkSize, maxSamples - samplesRecorded)\n      );\n      clampOutOfBoundsValues(chunkSliced);\n      if (!sampleCount) {\n        sampleCount = chunkSliced.length;\n      }\n      floatChunksByChannel.push(chunkSliced);\n    }\n    const interleaved = interleaveSampleChannels(floatChunksByChannel);\n    const interleaved16 = convertSamplesTo16Bit(interleaved);\n    recordedChunks.push(interleaved16);\n    samplesRecorded += sampleCount;\n    // should never be >, but just in case we did something wrong we use >=\n    if (samplesRecorded >= maxSamples) {\n      stop();\n    }\n    onUpdate(floatChunksByChannel);\n  }\n\n  /**\n   * @type {(wavBuffer: Uint8Array) => void}\n   */\n  let onDone;\n  /**\n   * @type {(error: unknown) => void}\n   */\n  let onError;\n  /**\n   * @type {Promise<Uint8Array>}\n   */\n  const mediaRecording = new Promise((resolve, reject) => {\n    onDone = resolve;\n    onError = reject;\n  });\n  let finished = false;\n\n  async function onFinish() {\n    if (finished) {\n      return;\n    }\n\n    // create wav file\n    try {\n      const blob = new Blob(recordedChunks);\n      const arrayBuffer = await blob.arrayBuffer();\n      const samplesInterleaved16 = new Float32Array(arrayBuffer);\n      const wavHeader = getWavFileHeaders({\n        channels: channelCount,\n        sampleRate: audioContext.sampleRate,\n        bitDepth: 16,\n        dataLength: samplesInterleaved16.byteLength,\n      });\n      const wavBuffer = new Uint8Array(\n        wavHeader.length + samplesInterleaved16.byteLength\n      );\n      wavBuffer.set(wavHeader);\n      wavBuffer.set(\n        new Uint8Array(samplesInterleaved16.buffer),\n        wavHeader.length\n      );\n      onDone(wavBuffer);\n    } catch (err) {\n      onError(err);\n    }\n\n    // clean up\n    const tracks = stream.getTracks();\n    for (const track of tracks) {\n      track.stop();\n    }\n    recorderNode.disconnect(audioContext.destination);\n    mediaStreamSourceNode.disconnect(recorderNode);\n    finished = true;\n  }\n\n  return {\n    stop,\n    mediaRecording,\n  };\n}\n","import React, {\n  useCallback,\n  useEffect,\n  useLayoutEffect,\n  useRef,\n  useState,\n} from 'react';\nimport { Form, Button, Collapse, Alert, Container } from 'react-bootstrap';\n\nimport {\n  findSamplePeak,\n  getAudioBufferForAudioFileData,\n} from './utils/audioData.js';\nimport { captureAudio, getAudioInputDevices } from './utils/recording.js';\n\nimport classes from './SampleRecord.module.scss';\n\nconst captureDevicePreferenceKey = 'capture_device_preference';\n\n/**\n * @typedef {{ deviceId: string; channelCount: number }} CaptureDevicePreference\n */\n\n/**\n * @type {Map<string, import('./utils/recording').AudioDeviceInfoContainer> | null}\n */\nlet cachedCaptureDevices = null;\n\n/**\n * @typedef {(audioFileBuffer: Uint8Array, userFile?: File) => Promise<'saved' | 'silent'>} RecordingCallback\n */\n\n/**\n * @param {(channels: Float32Array[]) => void} onRecordUpdate\n * @param {RecordingCallback} onRecordFinish\n */\nfunction useMediaRecording(onRecordUpdate, onRecordFinish) {\n  const restoringCaptureDevice = useRef(\n    /** @type {CaptureDevicePreference | null} */ (\n      JSON.parse(localStorage.getItem(captureDevicePreferenceKey) || 'null')\n    )\n  );\n  const [captureDevices, setCaptureDevices] = useState(cachedCaptureDevices);\n  const [accessState, setAccessState] = useState(\n    /** @type {'pending' | 'ok' | 'denied' | 'unavailable'} */ (\n      captureDevices ? 'ok' : 'pending'\n    )\n  );\n  const [selectedCaptureDeviceId, setSelectedCaptureDeviceId] = useState('');\n  useEffect(() => {\n    cachedCaptureDevices = captureDevices;\n    setAccessState('ok');\n  }, [captureDevices]);\n  const refreshCaptureDevices = useCallback(() => {\n    let cancelled = false;\n    getAudioInputDevices()\n      .then((devices) => {\n        if (cancelled) {\n          return;\n        }\n        if (devices.length) {\n          setCaptureDevices(\n            new Map(devices.map((d) => [d.device.deviceId, d]))\n          );\n          setSelectedCaptureDeviceId((id) => {\n            if (id) {\n              restoringCaptureDevice.current = null;\n              return id;\n            }\n            if (\n              restoringCaptureDevice.current &&\n              devices.find(\n                ({ device }) =>\n                  /** @type {NonNullable<CaptureDevicePreference>} */ (\n                    restoringCaptureDevice.current\n                  ).deviceId === device.deviceId\n              )\n            ) {\n              return restoringCaptureDevice.current.deviceId;\n            }\n            restoringCaptureDevice.current = null;\n            return devices[0].device.deviceId;\n          });\n        }\n      })\n      .catch((err) => {\n        if (cancelled) {\n          return;\n        }\n        if (err instanceof DOMException) {\n          if (err.name === 'NotAllowedError') {\n            setAccessState('denied');\n            return;\n          }\n          if (err.name === 'NotFoundError') {\n            setAccessState('unavailable');\n            return;\n          }\n        }\n        throw err;\n      });\n    return () => {\n      cancelled = true;\n    };\n  }, []);\n  const [selectedChannelCount, setSelectedChannelCount] = useState(1);\n  useEffect(() => {\n    const selectedDeviceInfo =\n      captureDevices && captureDevices.get(selectedCaptureDeviceId);\n    if (selectedDeviceInfo) {\n      if (\n        restoringCaptureDevice.current &&\n        restoringCaptureDevice.current.deviceId ===\n          selectedDeviceInfo.device.deviceId &&\n        restoringCaptureDevice.current.channelCount <=\n          selectedDeviceInfo.channelsAvailable\n      ) {\n        setSelectedChannelCount(restoringCaptureDevice.current.channelCount);\n      } else {\n        setSelectedChannelCount(selectedDeviceInfo.channelsAvailable);\n      }\n      restoringCaptureDevice.current = null;\n    }\n  }, [captureDevices, selectedCaptureDeviceId]);\n  useEffect(() => {\n    if (selectedCaptureDeviceId) {\n      localStorage.setItem(\n        captureDevicePreferenceKey,\n        JSON.stringify({\n          deviceId: selectedCaptureDeviceId,\n          channelCount: selectedChannelCount,\n        })\n      );\n    }\n  }, [selectedCaptureDeviceId, selectedChannelCount]);\n  /**\n   * @typedef {'ready' | 'capturing' | 'finalizing' | 'error'} CaptureState\n   */\n  const [captureState, setCaptureState] = useState(\n    /** @type {CaptureState} */ ('ready')\n  );\n  const [recordingError, setRecordingError] = useState(\n    /** @type {unknown} */ (null)\n  );\n  const [showSilenceWarning, setShowSilenceWarning] = useState(false);\n  useEffect(() => {\n    if (captureState !== 'ready') {\n      setShowSilenceWarning(false);\n    }\n  }, [captureState]);\n  const dismissSilenceWarning = useCallback(() => {\n    setShowSilenceWarning(false);\n  }, []);\n  // to be set when recording is started\n  const [stop, setStop] = useState({\n    /**\n     * @param {boolean} [cancel]\n     */\n    fn(cancel) {},\n  });\n  useEffect(() => {\n    return stop.fn;\n  }, [stop]);\n  const [sampleRate, setSampleRate] = useState(Infinity);\n  const [maxSamples, setMaxSamples] = useState(0);\n  const handleBeginRecording = useCallback(async () => {\n    let cancelled = false;\n    /**\n     * @param {string} deviceId\n     * @param {number} channelCount\n     */\n    const record = (deviceId, channelCount) =>\n      captureAudio({\n        deviceId,\n        channelCount,\n        onStart: (sampleRate, timeLimitSeconds) => {\n          const maxSamples = timeLimitSeconds * sampleRate;\n          setSampleRate(sampleRate);\n          setMaxSamples(maxSamples);\n          setCaptureState('capturing');\n        },\n        onUpdate: onRecordUpdate,\n      });\n    // if we haven't opened our device settings to get device info yet, let's\n    // still try to record with our last-used device\n    const tentativeDevice = restoringCaptureDevice.current;\n    const { mediaRecording, stop } = await (tentativeDevice\n      ? (async () => {\n          try {\n            return record(\n              tentativeDevice.deviceId,\n              tentativeDevice.channelCount\n            );\n          } catch (err) {\n            // ignore the NotFound exception if we hadn't refreshed our devices\n            // yet, just try the default instead\n            if (err instanceof DOMException && err.name === 'NotFoundError') {\n              return record(selectedCaptureDeviceId, selectedChannelCount);\n            }\n            throw err;\n          }\n        })()\n      : record(selectedCaptureDeviceId, selectedChannelCount));\n    setStop({\n      fn(cancel) {\n        stop();\n        if (cancel) {\n          cancelled = true;\n        }\n      },\n    });\n    /**\n     * @type {Uint8Array}\n     */\n    let wavBuffer;\n    try {\n      wavBuffer = await mediaRecording;\n    } catch (err) {\n      setRecordingError(err);\n      setCaptureState('error');\n      return;\n    }\n    if (cancelled) {\n      setCaptureState('ready');\n    } else {\n      setCaptureState('finalizing');\n      const result = await onRecordFinish(wavBuffer);\n      if (!cancelled) {\n        setCaptureState('ready');\n        if (result === 'silent') {\n          setShowSilenceWarning(true);\n        }\n      }\n    }\n  }, [\n    selectedCaptureDeviceId,\n    selectedChannelCount,\n    onRecordUpdate,\n    onRecordFinish,\n  ]);\n  /** @type {React.ChangeEventHandler<HTMLInputElement>} */\n  const importFile = useCallback(\n    (e) => {\n      if (e.target.files && e.target.files.length) {\n        const file = e.target.files[0];\n        file.arrayBuffer().then(async (arrayBuffer) => {\n          const audioFileBuffer = new Uint8Array(arrayBuffer);\n          /**\n           * @type {AudioBuffer}\n           */\n          let audioBuffer;\n          try {\n            audioBuffer = await getAudioBufferForAudioFileData(audioFileBuffer);\n          } catch (err) {\n            alert('Unsupported audio format detected');\n            return;\n          }\n          if (audioBuffer.length > 10 * audioBuffer.sampleRate) {\n            alert('Please select an audio file no more than 10 seconds long');\n            return;\n          }\n          setCaptureState('finalizing');\n          const result = await onRecordFinish(audioFileBuffer, file);\n          setCaptureState('ready');\n          if (result === 'silent') {\n            setShowSilenceWarning(true);\n          }\n        });\n      }\n    },\n    [onRecordFinish]\n  );\n  return {\n    captureDevices,\n    accessState,\n    selectedCaptureDeviceId,\n    selectedChannelCount,\n    captureState,\n    recordingError,\n    showSilenceWarning,\n    sampleRate,\n    maxSamples,\n    refreshCaptureDevices,\n    setSelectedCaptureDeviceId,\n    setSelectedChannelCount,\n    beginRecording: handleBeginRecording,\n    stopRecording: stop.fn,\n    importFile,\n    dismissSilenceWarning,\n  };\n}\n\nconst groupPixelWidth = 3;\n\n/**\n * @param {{\n *   canvas: HTMLCanvasElement;\n *   peaks: Float32Array;\n *   drawUntil: number;\n *   scaleCoefficient: number;\n * }} opts\n */\nfunction drawRecordingPeaks({ canvas, peaks, drawUntil, scaleCoefficient }) {\n  const barColor = '#fff';\n  const ctx = /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));\n  ctx.imageSmoothingEnabled = false;\n  const { width, height } = canvas;\n  ctx.clearRect(0, 0, width, height);\n  ctx.fillStyle = barColor;\n  for (let i = 0; i < drawUntil && i < peaks.length; i++) {\n    const peak = peaks[i];\n    const basePeakHeight = height * peak; // float\n    // make the bar always at least 1px tall to avoid empty sections\n    const scaledPeakHeight = Math.max(\n      Math.round(scaleCoefficient * basePeakHeight),\n      2\n    );\n    ctx.fillRect(\n      i * groupPixelWidth,\n      height - scaledPeakHeight,\n      groupPixelWidth - 1,\n      scaledPeakHeight\n    );\n  }\n}\n\n/**\n * @param {{ onRecordFinish: RecordingCallback }} props\n */\nfunction SampleRecord({ onRecordFinish }) {\n  /**\n   * @type {React.RefObject<HTMLCanvasElement>}\n   */\n  const recordButtonCanvasRef = useRef(null);\n\n  const groupSizeRef = useRef(0);\n  const peaksRef = useRef(new Float32Array());\n  const peakOffsetRef = useRef(0);\n  // each item in the queue is an array of channel chunks,\n  // each channel chunk being a Float32Array\n  const updatesQueueRef = useRef(/** @type {Float32Array[][]} */ ([]));\n  const sampleRateRef = useRef(Infinity);\n  const samplesRecordedRef = useRef(0);\n\n  const [secondsRecorded, setSecondsRecorded] = useState(0);\n\n  /**\n   * @type {(channels: Float32Array[]) => Promise<void>}\n   */\n  const onRecordUpdate = useCallback(async (channels) => {\n    const groupSize = groupSizeRef.current;\n    const peaks = peaksRef.current;\n    const updatesQueue = updatesQueueRef.current;\n\n    updatesQueue.push(channels);\n    samplesRecordedRef.current += channels[0].length;\n    setSecondsRecorded(\n      Math.floor(samplesRecordedRef.current / sampleRateRef.current)\n    );\n\n    const queuedSampleCount = updatesQueue.reduce(\n      (c, [{ length }]) => c + length,\n      0\n    );\n    if (queuedSampleCount >= groupSize) {\n      const samplesByChannel = await Promise.all(\n        channels\n          .map((_, ch) =>\n            updatesQueue.reduce((chunks, update) => [...chunks, update[ch]], [])\n          )\n          .map(async (chunks) => {\n            const arrayBuffer = await new Blob(chunks).arrayBuffer();\n            return new Float32Array(arrayBuffer);\n          })\n      );\n      const peaksByChannel = samplesByChannel.map((samples) =>\n        findSamplePeak(new Float32Array(samples.buffer, 0, groupSize))\n      );\n      peaks[peakOffsetRef.current++] = Math.max(...peaksByChannel);\n      drawRecordingPeaks({\n        canvas: /** @type {HTMLCanvasElement} */ (\n          recordButtonCanvasRef.current\n        ),\n        peaks,\n        drawUntil: peakOffsetRef.current,\n        scaleCoefficient: 0.3,\n      });\n      updatesQueueRef.current = [\n        samplesByChannel.map((samples) => samples.slice(groupSize)),\n      ];\n    }\n  }, []);\n\n  const {\n    captureDevices,\n    accessState,\n    selectedCaptureDeviceId,\n    selectedChannelCount,\n    captureState,\n    recordingError,\n    showSilenceWarning,\n    maxSamples,\n    sampleRate,\n    refreshCaptureDevices,\n    setSelectedCaptureDeviceId,\n    setSelectedChannelCount,\n    beginRecording,\n    stopRecording,\n    importFile,\n    dismissSilenceWarning,\n  } = useMediaRecording(onRecordUpdate, onRecordFinish);\n  sampleRateRef.current = sampleRate;\n\n  useEffect(() => {\n    const canvas = recordButtonCanvasRef.current;\n    if (canvas) {\n      canvas.width = canvas.offsetWidth;\n      canvas.height = canvas.offsetHeight;\n    }\n  }, [accessState]);\n\n  // set up empty recording waveform data when recording starts\n  useLayoutEffect(() => {\n    const canvas = recordButtonCanvasRef.current;\n    if (!canvas) {\n      return;\n    }\n    if (captureState !== 'finalizing') {\n      /** @type {CanvasRenderingContext2D} */ (\n        canvas.getContext('2d')\n      ).clearRect(0, 0, canvas.width, canvas.height);\n    }\n    if (captureState === 'capturing' && maxSamples) {\n      groupSizeRef.current = Math.floor(\n        (groupPixelWidth * maxSamples) / recordButtonCanvasRef.current.width\n      );\n      peaksRef.current = new Float32Array(\n        Math.floor(maxSamples / groupSizeRef.current)\n      );\n      peakOffsetRef.current = 0;\n      updatesQueueRef.current = [];\n      sampleRateRef.current = Infinity;\n      samplesRecordedRef.current = 0;\n      setSecondsRecorded(0);\n    }\n  }, [maxSamples, captureState]);\n\n  const [showingCaptureConfig, setShowingCaptureConfig] = useState(false);\n\n  useEffect(() => {\n    if (showingCaptureConfig) {\n      refreshCaptureDevices();\n    }\n  }, [showingCaptureConfig, refreshCaptureDevices]);\n\n  return (\n    <Container fluid=\"sm\">\n      {accessState === 'denied' ? (\n        <p>\n          Looks like you didn't grant access to your audio input device. Please\n          give Volca Sampler access, then{' '}\n          <Button\n            type=\"button\"\n            variant=\"secondary\"\n            onClick={refreshCaptureDevices}\n          >\n            try again\n          </Button>\n        </p>\n      ) : accessState === 'unavailable' ? (\n        <p>\n          Volca Sampler couldn't find any audio input devices. Please connect\n          one, then{' '}\n          <Button\n            type=\"button\"\n            variant=\"secondary\"\n            onClick={refreshCaptureDevices}\n          >\n            try again\n          </Button>\n        </p>\n      ) : (\n        <div>\n          <h2>Send a new sound to your Volca Sample!</h2>\n          {showSilenceWarning && (\n            <div className={classes.alertContainer}>\n              <Alert\n                dismissible\n                variant=\"warning\"\n                onClose={dismissSilenceWarning}\n              >\n                <Alert.Heading>\n                  Your recording was totally silent.\n                </Alert.Heading>\n                <p>\n                  Check the audio input settings and your connections, then try\n                  again.\n                </p>\n              </Alert>\n            </div>\n          )}\n          <Button\n            className={classes.recordButton}\n            type=\"button\"\n            variant={captureState === 'capturing' ? 'danger' : 'primary'}\n            size=\"lg\"\n            style={{ width: 250 }}\n            onClick={\n              captureState === 'capturing'\n                ? () => stopRecording()\n                : beginRecording\n            }\n            disabled={captureState === 'finalizing'}\n          >\n            <canvas ref={recordButtonCanvasRef} />\n            <span className={classes.mainText}>\n              {['capturing', 'finalizing'].includes(captureState)\n                ? 'Finished recording'\n                : 'Start recording'}\n            </span>\n            {['capturing', 'finalizing'].includes(captureState) && (\n              <span className={classes.timeRecorded}>\n                0:{String(secondsRecorded).padStart(2, '0')}\n              </span>\n            )}\n          </Button>\n          {['capturing', 'finalizing'].includes(captureState) ? (\n            <>\n              <br />\n              <br />\n              <Button\n                style={{ width: 250 }}\n                size=\"sm\"\n                type=\"button\"\n                variant=\"secondary\"\n                onClick={() => stopRecording(true)}\n              >\n                Cancel\n              </Button>\n            </>\n          ) : (\n            <>\n              <br />\n              <Button\n                style={{ width: 250 }}\n                type=\"button\"\n                variant=\"light\"\n                size=\"sm\"\n                onClick={() => setShowingCaptureConfig((showing) => !showing)}\n              >\n                Audio input settings {showingCaptureConfig ? 'â–²' : 'â–¼'}\n              </Button>\n              <Collapse in={showingCaptureConfig}>\n                <div>\n                  <Form.Group>\n                    <Form.Label>Capture Device</Form.Label>\n                    <Form.Select\n                      style={{ width: 250 }}\n                      value={selectedCaptureDeviceId}\n                      onChange={(e) =>\n                        setSelectedCaptureDeviceId(e.target.value)\n                      }\n                    >\n                      {captureDevices && accessState === 'ok' ? (\n                        [...captureDevices].map(([id, { device }]) => (\n                          <option key={id} value={id}>\n                            {device.label || id}\n                          </option>\n                        ))\n                      ) : (\n                        <option value=\"\" disabled>\n                          Loading devices...\n                        </option>\n                      )}\n                    </Form.Select>\n                  </Form.Group>\n                  <Form.Group>\n                    <Form.Label>Input channels</Form.Label>\n                    <Form.Select\n                      style={{ width: 250 }}\n                      value={selectedChannelCount}\n                      onChange={(e) =>\n                        setSelectedChannelCount(Number(e.target.value))\n                      }\n                    >\n                      {[1, 2].map((count) => (\n                        <option\n                          key={count}\n                          value={count}\n                          disabled={\n                            !captureDevices ||\n                            !captureDevices.has(selectedCaptureDeviceId) ||\n                            /** @type {import('./utils/recording').AudioDeviceInfoContainer} */ (\n                              captureDevices.get(selectedCaptureDeviceId)\n                            ).channelsAvailable < count\n                          }\n                        >\n                          {count === 1 ? 'Mono' : 'Stereo (summed to mono)'}\n                        </option>\n                      ))}\n                    </Form.Select>\n                  </Form.Group>\n                  <br />\n                </div>\n              </Collapse>\n            </>\n          )}\n        </div>\n      )}\n      {(captureState === 'error' && recordingError) || null}\n      <br />\n      <Button\n        style={{ width: 250 }}\n        type=\"button\"\n        variant=\"secondary\"\n        onClick={(e) => {\n          const input = e.currentTarget.querySelector('input');\n          if (input && e.target !== input) {\n            input.click();\n          }\n        }}\n      >\n        Or import an audio file\n        <input\n          hidden\n          type=\"file\"\n          accept=\"audio/*,.wav,.mp3,.ogg\"\n          onChange={importFile}\n        />\n      </Button>\n    </Container>\n  );\n}\n\nexport default SampleRecord;\n","import React, {\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from 'react';\nimport { Accordion, ListGroup, Offcanvas } from 'react-bootstrap';\n\nimport Header from './Header.js';\nimport SampleList from './SampleList.js';\nimport SampleDetail from './SampleDetail.js';\nimport SampleDetailReadonly from './SampleDetailReadonly.js';\nimport SampleRecord from './SampleRecord.js';\nimport {\n  getFactorySamples,\n  SampleContainer,\n  storeAudioSourceFile,\n} from './store.js';\nimport { getSamplePeaksForAudioBuffer } from './utils/waveform.js';\nimport { getAudioBufferForAudioFileData } from './utils/audioData.js';\n\nimport classes from './App.module.scss';\n\nconst sessionStorageKey = 'focused_sample_id';\n\nfunction App() {\n  const [userSamples, setUserSamples] = useState(\n    /** @type {Map<string, SampleContainer>} */ (new Map())\n  );\n  const [factorySamples, setFactorySamples] = useState(\n    /** @type {Map<string, SampleContainer>} */ (new Map())\n  );\n  const allSamples = useMemo(() => {\n    return new Map([...userSamples, ...factorySamples]);\n  }, [userSamples, factorySamples]);\n  useEffect(() => {\n    getFactorySamples().then(setFactorySamples).catch(console.error);\n  }, []);\n  const restoredFocusedSampleId = sessionStorage.getItem(sessionStorageKey);\n  const [focusedSampleId, setFocusedSampleId] = useState(\n    /** @type {string | null} */ (\n      restoredFocusedSampleId && typeof restoredFocusedSampleId === 'string'\n        ? restoredFocusedSampleId\n        : null\n    )\n  );\n  useEffect(() => {\n    if (focusedSampleId) {\n      sessionStorage.setItem(sessionStorageKey, focusedSampleId);\n    } else {\n      sessionStorage.removeItem(sessionStorageKey);\n    }\n  }, [focusedSampleId]);\n  const [loadingSamples, setLoadingSamples] = useState(true);\n  {\n    const initiallyFocusedSampleIdRef = useRef(focusedSampleId);\n    useEffect(() => {\n      // TODO: error handling\n      SampleContainer.getAllFromStorage()\n        .then((storedSamples) => {\n          if (\n            initiallyFocusedSampleIdRef.current &&\n            !storedSamples.some(\n              ({ id }) => initiallyFocusedSampleIdRef.current === id\n            )\n          ) {\n            setFocusedSampleId(null);\n          }\n          setUserSamples(\n            (samples) =>\n              new Map([\n                ...samples,\n                ...storedSamples.map(\n                  (sample) =>\n                    /** @type {[string, SampleContainer]} */ ([\n                      sample.id,\n                      sample,\n                    ])\n                ),\n              ])\n          );\n          // TODO: automatically set focused sample id to first.. easier with useReducer maybe\n        })\n        .finally(() => {\n          setLoadingSamples(false);\n        });\n    }, []);\n  }\n\n  /**\n   * @type {(audioFileBuffer: Uint8Array, userFile?: File) => Promise<'saved' | 'silent'>}\n   * */\n  const handleRecordFinish = useCallback(async (audioFileBuffer, userFile) => {\n    const audioBuffer = await getAudioBufferForAudioFileData(audioFileBuffer);\n    /**\n     * @type {[number, number]}\n     */\n    const trimFrames = [0, 0];\n    const waveformPeaks = await getSamplePeaksForAudioBuffer(\n      audioBuffer,\n      trimFrames\n    );\n    if (\n      [...waveformPeaks.positive, ...waveformPeaks.negative].every(\n        (peak) => peak === 0\n      )\n    ) {\n      return 'silent';\n    }\n    const sourceFileId = await storeAudioSourceFile(audioFileBuffer);\n    /**\n     * @type {string}\n     */\n    let name = '';\n    let userFileExtension = '';\n    if (userFile) {\n      const lastDotIndex = userFile.name.lastIndexOf('.');\n      if (lastDotIndex > 0) {\n        name = userFile.name.slice(0, lastDotIndex);\n        userFileExtension = userFile.name.slice(lastDotIndex);\n      } else {\n        name = userFile.name;\n      }\n    } else {\n      name = 'New sample';\n    }\n    const sample = new SampleContainer.Mutable({\n      name,\n      sourceFileId,\n      trim: {\n        frames: trimFrames,\n        waveformPeaks,\n      },\n      userFileInfo: userFile && {\n        type: userFile.type,\n        ext: userFileExtension,\n      },\n    });\n    await sample.persist();\n    setUserSamples((samples) => new Map([[sample.id, sample], ...samples]));\n    setFocusedSampleId(sample.id);\n    return 'saved';\n  }, []);\n\n  /**\n   * @type {(id: string, update: import('./store').SampleMetadataUpdateArg) => void}\n   */\n  const handleSampleUpdate = useCallback((id, updater) => {\n    setUserSamples((samples) => {\n      const sample = samples.get(id);\n      if (sample && sample instanceof SampleContainer.Mutable) {\n        const updated = sample.update(updater);\n        if (updated !== sample) {\n          return new Map(samples).set(sample.id, updated);\n        }\n      }\n      return samples;\n    });\n  }, []);\n\n  const allSamplesRef = useRef(allSamples);\n  allSamplesRef.current = allSamples;\n  const handleSampleDuplicate = useCallback(\n    /**\n     * @param {string} id\n     */\n    (id) => {\n      const sample = allSamplesRef.current.get(id);\n      if (sample) {\n        const newSample = sample.duplicate();\n        setUserSamples(\n          (samples) => new Map([[newSample.id, newSample], ...samples])\n        );\n        // TODO: scroll new sample into view\n        setFocusedSampleId(newSample.id);\n      }\n    },\n    []\n  );\n\n  const userSamplesRef = useRef(userSamples);\n  userSamplesRef.current = userSamples;\n  const handleSampleDelete = useCallback(\n    /**\n     * @param {string} id\n     */\n    (id) => {\n      const userSamples = userSamplesRef.current;\n      const sample = userSamples.get(id);\n      if (sample && sample instanceof SampleContainer.Mutable) {\n        sample.remove();\n        /** @type {string | null} */\n        let nextFocusedSampleId = null;\n        let awaitingNextBeforeBreak = false;\n        for (const [, sample] of userSamples) {\n          if (awaitingNextBeforeBreak) {\n            nextFocusedSampleId = sample.id;\n            break;\n          }\n          if (sample.id === id) {\n            if (!nextFocusedSampleId) {\n              awaitingNextBeforeBreak = true;\n              continue;\n            }\n            break;\n          }\n          nextFocusedSampleId = sample.id;\n        }\n        setFocusedSampleId(nextFocusedSampleId);\n        setUserSamples((samples) => {\n          const newSamples = new Map(samples);\n          newSamples.delete(sample.id);\n          return newSamples;\n        });\n      }\n    },\n    []\n  );\n\n  const [sidebarOpen, setSidebarOpen] = useState(false);\n  const handleSampleSelect = useCallback(\n    /**\n     * @param {string | null} sampleId\n     */\n    (sampleId) => {\n      setFocusedSampleId(sampleId);\n      setSidebarOpen(false);\n    },\n    []\n  );\n\n  const handleMenuOpen = useCallback(() => setSidebarOpen(true), []);\n  const handleHeaderClick = useCallback(() => setFocusedSampleId(null), []);\n\n  return (\n    <div>\n      <Header onMenuOpen={handleMenuOpen} onHeaderClick={handleHeaderClick} />\n      <Offcanvas show={sidebarOpen} onHide={() => setSidebarOpen(false)}>\n        <Offcanvas.Header closeButton />\n        <Offcanvas.Body>\n          <ListGroup>\n            <ListGroup.Item\n              as=\"button\"\n              onClick={() => handleSampleSelect(null)}\n            >\n              New Sample\n            </ListGroup.Item>\n            {loadingSamples ? 'Loading...' : null}\n            {!loadingSamples && (\n              <Accordion\n                defaultActiveKey={userSamples.size ? 'user' : 'factory'}\n              >\n                <Accordion.Item eventKey=\"user\">\n                  <Accordion.Header>Your Samples</Accordion.Header>\n                  <Accordion.Body style={{ padding: 0 }}>\n                    <SampleList\n                      samples={userSamples}\n                      selectedSampleId={focusedSampleId}\n                      onSampleSelect={handleSampleSelect}\n                    />\n                  </Accordion.Body>\n                </Accordion.Item>\n                <Accordion.Item eventKey=\"factory\">\n                  <Accordion.Header>Factory Samples</Accordion.Header>\n                  <Accordion.Body style={{ padding: 0 }}>\n                    <SampleList\n                      samples={factorySamples}\n                      selectedSampleId={focusedSampleId}\n                      onSampleSelect={handleSampleSelect}\n                    />\n                  </Accordion.Body>\n                </Accordion.Item>\n              </Accordion>\n            )}\n          </ListGroup>\n        </Offcanvas.Body>\n      </Offcanvas>\n      <div className={classes.mainLayout}>\n        <div className={classes.focusedSampleContainer}>\n          {focusedSampleId &&\n            (() => {\n              const sample = allSamples.get(focusedSampleId) || null;\n              if (!sample) {\n                return null;\n              }\n              if (sample instanceof SampleContainer.Mutable) {\n                return (\n                  <SampleDetail\n                    sample={sample}\n                    onSampleUpdate={handleSampleUpdate}\n                    onSampleDuplicate={handleSampleDuplicate}\n                    onSampleDelete={handleSampleDelete}\n                  />\n                );\n              }\n              return (\n                <SampleDetailReadonly\n                  sample={sample}\n                  onSampleDuplicate={handleSampleDuplicate}\n                />\n              );\n            })()}\n          {!focusedSampleId && (\n            <SampleRecord onRecordFinish={handleRecordFinish} />\n          )}\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","/**\n * @param {import('web-vitals').ReportHandler} [onPerfEntry]\n */\nconst reportWebVitals = (onPerfEntry) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport './bootstrap.scss';\nimport App from './App.js';\nimport reportWebVitals from './reportWebVitals.js';\nimport { AudioPlaybackContextProvider } from './utils/audioData.js';\n\n// polyfills\nif (!Blob.prototype.arrayBuffer) {\n  Blob.prototype.arrayBuffer = function arrayBuffer() {\n    return new Response(this).arrayBuffer();\n  };\n}\n\nReactDOM.render(\n  <React.StrictMode>\n    <AudioPlaybackContextProvider>\n      <App />\n    </AudioPlaybackContextProvider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"form-switch\":\"SlotNumberInput_form-switch__39Wtl\",\"form-check-input\":\"SlotNumberInput_form-check-input__oNf4Z\",\"slotNumberRow\":\"SlotNumberInput_slotNumberRow__kQwOw\",\"slotNumberContainer\":\"SlotNumberInput_slotNumberContainer__1q7P1\",\"arrowControls\":\"SlotNumberInput_arrowControls__1LPAC\",\"slotNumber\":\"SlotNumberInput_slotNumber__GC-i7\",\"active\":\"SlotNumberInput_active__2zN4D\",\"digitBlinkEffect\":\"SlotNumberInput_digitBlinkEffect__1_u8n\",\"point\":\"SlotNumberInput_point__3pJD3\",\"warning\":\"SlotNumberInput_warning__3NAeN\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"titleBar\":\"Header_titleBar__3BLa-\",\"menuIcon\":\"Header_menuIcon__swn7p\",\"title\":\"Header_title__R3bRx\",\"titleText\":\"Header_titleText__3e5ME\",\"titleR\":\"Header_titleR__3QRgv\",\"titleStarburst\":\"Header_titleStarburst__1oLYP\",\"titleGraphic\":\"Header_titleGraphic__3S89F\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"form-switch\":\"QualityBitDepthControl_form-switch__3nCZi\",\"form-check-input\":\"QualityBitDepthControl_form-check-input__2KgZ8\",\"qualityBitDepthWrapper\":\"QualityBitDepthControl_qualityBitDepthWrapper__2qLOe\",\"label\":\"QualityBitDepthControl_label___ohmN\",\"ticks\":\"QualityBitDepthControl_ticks__1u5GH\",\"tickLabel\":\"QualityBitDepthControl_tickLabel__2jXRm\",\"tickMark\":\"QualityBitDepthControl_tickMark__24xm0\",\"annotations\":\"QualityBitDepthControl_annotations__3mXj2\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"form-switch\":\"SampleDetail_form-switch__31CS2\",\"form-check-input\":\"SampleDetail_form-check-input__1NWgi\",\"optionsButton\":\"SampleDetail_optionsButton__k0UjV\",\"normalizeControlWrapper\":\"SampleDetail_normalizeControlWrapper__1yc_t\",\"waveformBoundingBox\":\"SampleDetail_waveformBoundingBox__2GVCa\",\"slotNumber\":\"SampleDetail_slotNumber__3sgS6\",\"point\":\"SampleDetail_point__3d7qL\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"alertContainer\":\"SampleRecord_alertContainer__vjGNP\",\"recordButton\":\"SampleRecord_recordButton__3R-KX\",\"mainText\":\"SampleRecord_mainText__2dca6\",\"timeRecorded\":\"SampleRecord_timeRecorded__3FGTe\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"form-switch\":\"WaveformEdit_form-switch__2DZid\",\"form-check-input\":\"WaveformEdit_form-check-input__2TImp\",\"scaleButtonsContainer\":\"WaveformEdit_scaleButtonsContainer__248kb\",\"scaleButtons\":\"WaveformEdit_scaleButtons__3u8fE\",\"waveformContainer\":\"WaveformEdit_waveformContainer__Qq3MI\",\"playbackOverlay\":\"WaveformEdit_playbackOverlay__1_jAo\",\"playbackActive\":\"WaveformEdit_playbackActive__hTwgX\",\"playback\":\"WaveformEdit_playback__2tuIe\",\"cursor\":\"WaveformEdit_cursor__1Ntb3\",\"trim\":\"WaveformEdit_trim__1GV76\",\"bar\":\"WaveformEdit_bar__1KFgt\",\"handle\":\"WaveformEdit_handle__23NoG\",\"time\":\"WaveformEdit_time__YX5rg\",\"left\":\"WaveformEdit_left__3Jfpn\",\"right\":\"WaveformEdit_right__35CjW\",\"waveformOverlay\":\"WaveformEdit_waveformOverlay__3oZfw\",\"playbackButtonContainer\":\"WaveformEdit_playbackButtonContainer__3tLJJ\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"form-switch\":\"App_form-switch__3Ht4D\",\"form-check-input\":\"App_form-check-input__19Z6o\",\"mainLayout\":\"App_mainLayout__3UKwp\",\"focusedSampleContainer\":\"App_focusedSampleContainer__1lol8\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"form-switch\":\"NormalizeSwitch_form-switch__pmDx5\",\"form-check-input\":\"NormalizeSwitch_form-check-input__trt4D\",\"normalizeControlWrapper\":\"NormalizeSwitch_normalizeControlWrapper__3yf2V\"};"],"sourceRoot":""}